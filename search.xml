<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[为美好的世界献上祝福]]></title>
      <url>https://arondight.github.io/2016/05/03/%E4%B8%BA%E7%BE%8E%E5%A5%BD%E7%9A%84%E4%B8%96%E7%95%8C%E7%8C%AE%E4%B8%8A%E7%A5%9D%E7%A6%8F/</url>
      <content type="html"><![CDATA[<h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>说一下最近发生的两件事吧。</p>
<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>第一件事是在Github 上找到了自己三年前用的一些配置文件，于是晚上本地拉了一个空分支fetch 下来后push 了上去。因为整套配置文件都是用软连接分发的，而目录架构又三年多没有变过，所以当想用Vim 打开里面的配置看看当时写成什么样子的时候，却看到了一个很陌生的界面。因为仓库检出到了三年前的分支，所以我看到了三年前自己使用的Vim。</p>
<p>三年前我用着这个配置写过什么东西，最后那些事情也构成了现在的我。</p>
<a id="more"></a>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>第二件事是感觉越来越看不清未来的大致轮廓了，将来会做什么行业，会在哪个城市，一切都变得模糊了起来。很多周围的事物，包括以前认为理所当然的事情都变得不确定。“自己以后肯定会继续写程序吧”，“肯定会选择留在北京吧”，“肯定会在技术上有所发展吧”，然而这些“理所当然”的事情自己越发都觉得难以相信。</p>
<p>较之于爱好和方向，最重要的问题已经变成了如何更好地生活，其余的只是生活的手段，包括曾经自己坚持的东西。</p>
<h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>说一下这个行业吧，不只是程序员这一行，而是IT 这个行业，例如程序员、运维、测试之类的。</p>
<h3 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h3><p>大学里我对IT 的印象，编程几乎占了所有的比重。虽然和有的人说大学想学医却最终学了计算机，其实一半是撒谎，能够写程序也是高中时期我的梦想之一。所以从某些意义上来说，我也算选对了一个大学。所以从这个意义上，我也理所当然的毕业后成了一个程序员。虽然毕业之前很长时间都在踹踹不安，是不是应该考研，万一毕业后生活在社会最底层怎么办，以后应该向哪个领域发展……然而毕业后就发现曾经的不安并没有什么实际的意义，只有去工作才有工资，不管方向是不是很合口，你总得找一份。</p>
<p>第一家公司是一个做手机操作系统的公司，说实话并没写多少代码，基本都是二次开发，晚上经常八点才下班。现在的公司是做电脑操作系统的，编程的工作也不是很多，较之深度反而更加看重广度，好在一般不到六点就走人了。</p>
<p>然而无论如何，就结果而言我并没有像学生时代设想的那样成为一个100% 的程序员。</p>
<h3 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h3><p>也是一半撒谎，有时我会和别人说，有点后悔当初没有按照父母的安排在家乡进事业单位，否则就能过上安安稳稳的生活了，然而至少就现在而言我半点不曾后悔过。毕业后跟我去了同一个大学的两个兄弟留在了家乡，那里物价不贵，房租便宜，生活节奏很慢，晚上从七点开始，冬天六点多下班公交可能就停了。而我只身来了北京，一个晚上从九点开始的城市，物价很贵，房租普遍一个月一千五，房价高的几乎没有留下的可能性。</p>
<p>然而将安稳的生活和四倍的工资相比，我选择了后者，纵使代价是只能在一个远离家乡的地方漂着。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>好几次我妈给我打电话，说北京干够了就回家吧。挂上电话想想自己是不是真的能回去呢。IT 是一个很矛盾的行业，相对于传统行业好混一点，但是只有一线城市才有更多的机会。相较于在一个金钱贬值的地方多赚一点，似乎在三线城市有一份收入不高但安稳的工作也挺不错吧。然而无论混的好坏，很少见到一个做IT 的出来几年就回去的。如果真的回了家乡，那么敲键盘就很难赚到钱了，除了敲键盘，你还有什么吃饭的技能呢。</p>
<p>你只能在一个自我价值贬值的地方才能够提升自身的存在价值，我觉得对于不少人而言做IT 就是这么个东西，至少对于现在的我而言是这样的。</p>
<h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>说一些其他的事情吧。</p>
<h3 id="1-2"><a href="#1-2" class="headerlink" title="1"></a>1</h3><p>最近开始变得越来越懒了，下班回来以后在群里扯扯淡，打开哔哩哔哩追追番，然后发呆一会儿，就到了睡觉的时间。然而就在三四个月前的时候还经常晚上在电脑前敲代码很久，那个时期我真的会去认认真真的花上业余时间去学一些东西。当然现在也想学一些东西，例如Java，例如服务器端开发，例如NodeJS，有一段时间还曾经想学Common Lisp，然而这些东西我都没有认真的开始学过。有时候也在想，以后转行该怎么办，总得有一门拿得出手的手艺，所以总得有一个确定而且熟悉的方向。然而又转念一想，以后做什么还都是未知，也没有必要非得这么着急去学精一门技能吧。</p>
<p>我说不好这中间到底有什么改变了，然而相对于学习新的知识，能够生活的轻松一点成了我当下切实的愿望。</p>
<h3 id="2-2"><a href="#2-2" class="headerlink" title="2"></a>2</h3><p>最近看了两部很喜欢的动画，一部是《为美好的世界献上祝福！》，另一部是《Re：从零开始的异世界生活》，两部动画都是发生在异世界的故事。在异世界中认识各式各样的人，发生各种各样的故事，因为不同的目的开始旅行，因为不同的目的停止旅行。大概我很喜欢这种浪漫主义的故事，所以这样的作品对我有着致命的诱惑力。然而如果真的说给我一次去异世界的机会，恐怕我不会踏上那段旅程吧。相对于一段全新的生活，现代科技和文明带来的生活保障恐怕重要的多。然而我还是无法抵挡任何“异世界中踏上旅途”的设定，这种作品对我而言可以说是精神鸦片一样的存在。</p>
<p>大约我的生活太缺少这样非日常的元素了。</p>
<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>说一下现在吧。</p>
<p>在学生时代我大约会很喜欢说自己的现在，然而此时此刻却写不出什么东西——现在就那样，没啥好说的。然而无论自己觉得现在的生活是否有意义，我所做的琐事也会一点点构建自身，像开头说的那样，三年后这些琐事也会构成我的一部分吧。</p>
<p>说来也巧，也正是三年前我开始尝试着去看动漫，此后一发不可收拾。当时很喜欢的一部作品是奈绪蘑菇的《空之境界》，这部作品本篇一共三本小说，后来蘑菇又写了《空之境界 未来福音》作为故事的补完。《未来福音》的画廊中讲了式和干也在《矛盾螺旋》之后的新年里去神社做参拜的故事，在矛盾螺旋事件结束后，式和干也在新年参拜中各自许下自己的新年愿望。当面对式“肯定又是类似世界和平之类”的玩笑时，干也让人很舒服的笑着说“嘛，差不多吧”，然后一句画外音让我至今难忘。</p>
<blockquote>
<p>惟愿你与围绕你的这个世界，未来也能一直幸福下去。</p>
<p>祈愿中满溢着来自未来的福音。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用GPG签名Git提交和标签]]></title>
      <url>https://arondight.github.io/2016/04/17/%E4%BD%BF%E7%94%A8GPG%E7%AD%BE%E5%90%8DGit%E6%8F%90%E4%BA%A4%E5%92%8C%E6%A0%87%E7%AD%BE/</url>
      <content type="html"><![CDATA[<h2 id="Pretty-Good-Privacy"><a href="#Pretty-Good-Privacy" class="headerlink" title="Pretty Good Privacy"></a>Pretty Good Privacy</h2><h3 id="GPG-是什么"><a href="#GPG-是什么" class="headerlink" title="GPG 是什么"></a>GPG 是什么</h3><p>提GPG 之前需要提一个软件叫PGP。PGP 是“Pretty Good Privacy” 的缩写，中文直译为“完美隐私”，名字言简意赅，上来就把软件的用途拍用户脸上。然而PGP 不是自由软件，所以自由软件基金会决定开发一个替代PGP 的自由软件，于是有了GPG（GnuPG）。</p>
<p>GPG 可以提供对信息、文件的签名和验证，或者是加密和解密，主要用于不安全网络上的信息传输。为此GPG 需要一个密钥环，GPG 使用私钥和公钥分别完成签名和加密，对应地验证和解密由公钥和私钥完成。</p>
<a id="more"></a>
<h3 id="主钥、从钥、公钥、私钥"><a href="#主钥、从钥、公钥、私钥" class="headerlink" title="主钥、从钥、公钥、私钥"></a>主钥、从钥、公钥、私钥</h3><p>然而GPG 密钥环并不只有一对公钥和私钥，如果称公钥和其对应的私钥为一个密钥对的话，那么一个GPG 密钥环可以拥有很多个密钥对，每一个密钥对都由一个钥匙号（key ID）标识，被称为钥匙。其中有一个钥匙拥有签名其他钥匙的功能（可以在密钥环中创建钥匙），这个钥匙被称为主钥，其他的钥匙则被称为从钥。</p>
<p>下面列出了我在使用的一个密钥环，首先是公钥。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gpg --list-keys</span><br><span class="line"><span class="section">/home/&lt;user&gt;/.gnupg/pubring.kbx</span><br><span class="line">---------------------------------</span></span><br><span class="line">pub   rsa4096/B66CC194 2016-04-15 [SC]</span><br><span class="line">uid         [ 绝对 ] Arondight &lt;shell<span class="emphasis">_way@foxmail.com&gt;</span><br><span class="line">sub   rsa4096/F96E3CB7 2016-04-15 [E]</span></span><br></pre></td></tr></table></figure>
<p>然后是私钥。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gpg --list-secret-keys</span><br><span class="line"><span class="section">/home/&lt;user&gt;/.gnupg/pubring.kbx</span><br><span class="line">---------------------------------</span></span><br><span class="line">sec   rsa4096/B66CC194 2016-04-15 [SC]</span><br><span class="line">uid         [ 绝对 ] Arondight &lt;shell<span class="emphasis">_way@foxmail.com&gt;</span><br><span class="line">ssb   rsa4096/F96E3CB7 2016-04-15 [E]</span></span><br></pre></td></tr></table></figure>
<p>GPG 列出的每个密钥环第一行一定是主钥，其余的则为从钥，可以看到上面的密钥环中只有一个主钥和一个从钥。每个密钥后面有许多信息描述它的属性，例如<code>sec   rsa4096/B66CC194 2016-04-15 [SC]</code> 代表这是一个主钥的私钥，加密算法为rsa，长度4096 位，主钥的钥匙号为<code>B66CC194</code>，创建于2016 年4 月15 日，功能为<code>SC</code>。</p>
<p>不难看出一个GPG 密钥环一共有四种类型的密钥，如果按照上面指令的样例输出来看的话则如下表。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>代表</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>sec</td>
<td>SECret key</td>
<td>主钥的私钥</td>
</tr>
<tr>
<td>pub</td>
<td>PUBlic key</td>
<td>主钥的公钥</td>
</tr>
<tr>
<td>ssb</td>
<td>Secret SuBkey</td>
<td>从钥的私钥</td>
</tr>
<tr>
<td>sub</td>
<td>public SUBkey</td>
<td>从钥的公钥</td>
</tr>
</tbody>
</table>
<p>至于这些钥匙的作用可以查看它们的功能，常用的功能有三种。</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>代表</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>S</td>
<td>Signing</td>
<td>签名和验证信息</td>
</tr>
<tr>
<td>E</td>
<td>Encryption</td>
<td>加密和解密信息</td>
</tr>
<tr>
<td>C</td>
<td>Certification</td>
<td>签名和验证钥匙</td>
</tr>
</tbody>
</table>
<p>注意功能是针对一个钥匙而言的，由其中的公钥和私钥共同完成。其中加密和解密分别由钥匙的公钥和私钥完成，签名和验证则分别由私钥和公钥完成。一般地，GPG 密钥环中钥匙的公钥需要公布到网络上，也就意味着：</p>
<ol>
<li>所有人都能用你公布的公钥加密信息，加密后的信息只有持有私钥的你才能够解密。</li>
<li>你可以使用自己持有的私钥签名信息，所有人都能够用你公布的公钥验证签名的合法性。</li>
</ol>
<p>默认地，GPG 生成的密钥环，主钥用于签名和验证，从钥用于加密和解密。</p>
<h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><p>首先需要生成一个GPG 密钥环，GPG 在生成密钥的时候会使用一个根据你的操作生成的随机数，所以你可以在GPG 生成密钥的时候多做一些操作，例如点鼠标、敲键盘、复制文件等等。你可以利用<code>dd</code> 指令在生成密钥的期间做一些读写操作以让随机数字发生器获得足够的熵数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dd <span class="keyword">if</span>=<span class="regexp">/dev/</span>random <span class="keyword">of</span>=<span class="regexp">/dev/</span><span class="literal">null</span> bs=<span class="number">4</span>M</span><br></pre></td></tr></table></figure>
<p>然后可以生成GPG 密钥环，推荐使用<code>--full-gen-key</code> 选项来启用所有的功能。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gpg <span class="comment">--full-gen-key</span></span><br></pre></td></tr></table></figure>
<p>其中需要注意的事情有以下几项：</p>
<ol>
<li>密钥种类：形如<code>method1 and method2</code> 的选项是生成主钥和一个从钥，默认可以用于签名和加密，形如<code>method</code> 的选项只生成主钥，默认只能用于签名。</li>
<li>密钥长度：越长越安全，同时加密解密的时间花费越多，选择一个你认为合理的长度。</li>
<li>有效期限：你需要选择一个你认为合理的有效期限，钥匙到期后，签名将失效，GPG 服务器也会删除其公钥，所以一般来说你需要使用一个永不过期的钥匙。</li>
<li>钥匙密码：一定要为你的钥匙设置一个足够强壮的密码！</li>
</ol>
<h3 id="上传公钥到服务器"><a href="#上传公钥到服务器" class="headerlink" title="上传公钥到服务器"></a>上传公钥到服务器</h3><p>现在你可以将你的公钥上传到任意GPG 服务器上了，这可以方便他人导入公钥以验证你的签名。通过服务器的交换机制，全球所有的GPG 服务器都会得到你的公钥。你可以列出你现在所拥有的公钥。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gpg --list-keys</span><br><span class="line"><span class="section">/home/&lt;user&gt;/.gnupg/pubring.kbx</span><br><span class="line">---------------------------------</span></span><br><span class="line">pub   rsa4096/B66CC194 2016-04-15 [SC]</span><br><span class="line">uid         [ 绝对 ] Arondight &lt;shell<span class="emphasis">_way@foxmail.com&gt;</span><br><span class="line">sub   rsa4096/F96E3CB7 2016-04-15 [E]</span></span><br></pre></td></tr></table></figure>
<p>可以看到两个公钥，分别属于主钥<code>B66CC194</code> 和从钥<code>F96E3CB7</code>。上传时指定主钥的钥匙号（key ID）即可，GPG 会将密钥环中的公钥上传到指定的服务器。</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gpg --keyserver <span class="built_in">keys</span>.gnupg.net --send-<span class="built_in">keys</span> &lt;<span class="built_in">key</span> ID&gt;</span><br></pre></td></tr></table></figure>
<h3 id="上传公钥到GitHub"><a href="#上传公钥到GitHub" class="headerlink" title="上传公钥到GitHub"></a>上传公钥到GitHub</h3><p>GitHub 刚刚发布了支持GPG 签名的消息，所以你可以选择使用GitHub 托管你的仓库。首先你需要以文本形式导出你主钥的公钥。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gpg -<span class="selector-tag">a</span> -o gnupg<span class="selector-class">.pub</span> --export &lt;key ID&gt;</span><br></pre></td></tr></table></figure>
<p>然后打开你的GitHub <a href="https://github.com/settings/keys" target="_blank" rel="external">密钥管理</a>界面，根据文件<code>gnupg.pub</code> 为你的GitHub 账户配置用于验证签名的公钥。</p>
<blockquote>
<p>注意：这一步不是必须的，你不一定要使用GitHub，或许你更喜欢使用其他的商业产品，或者自己搭建一个Git 服务器。Git 本身就是支持GPG 签名的，GitHub 对GPG 的支持仅是把验证结果在网页上显示出来（使用你上传的公钥）。</p>
</blockquote>
<h3 id="导出指纹"><a href="#导出指纹" class="headerlink" title="导出指纹"></a>导出指纹</h3><p>然而不幸的是，任何人都可以冒充你的名义上传公钥到GPG 服务器，所以对方搜到以你的名义发布的公钥，不一定真的是你发布的。为了避免这个问题，你需要公布主钥的指纹。GPG 导入公钥后需要手动设置信任度。这时候对方就可以通过对比计算得到的主钥指纹和你提供的主钥指纹，来确定导入的主钥的合法性。</p>
<p>你可以像下面一样导出指纹。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gpg --fingerprint &lt;key ID&gt; <span class="params">| perl -nE '$.-2 <span class="keyword">or</span> s/^\h+// <span class="keyword">and</span> print' |</span> tee fingerprint</span><br></pre></td></tr></table></figure>
<p>然后将<code>fingerprint</code> 文件提交到你的项目仓库中，或者公布在网络的其他位置。</p>
<blockquote>
<ol>
<li>你只需（只能）导出主钥的指纹，对方也只需要验证主钥的指纹，因为主钥的公钥可以验证从钥。</li>
<li>你可以通过<code>--export-ownertrust</code> 和<code>--import-ownertrust</code> 来直接导出和导入信任度，但是不推荐这样做。</li>
</ol>
</blockquote>
<h3 id="签名提交和标签"><a href="#签名提交和标签" class="headerlink" title="签名提交和标签"></a>签名提交和标签</h3><p>首先你需要为Git 设置一个用于签名的私钥，通常来说所有的个人项目都用一个私钥进行签名，所以建议设置为全局配置。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global <span class="keyword">user</span>.signingkey <span class="variable">&lt;key ID&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后就可以使用这个私钥来签名提交。</p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -<span class="keyword">S</span></span><br></pre></td></tr></table></figure>
<p>或者签名标签了。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">-s</span> <span class="tag">&lt;tag&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果你想全局默认使用GPG 签名提交，可以全局将<code>commit.gpgsign</code> 设置为<code>true</code>。</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --<span class="keyword">global</span> commit.gpgsign <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="关于私钥"><a href="#关于私钥" class="headerlink" title="关于私钥"></a>关于私钥</h3><p>任何情况向下都不要把私钥泄露给除了你之外的任何人。如果需要向对方发送加密信息，请让对方提供指纹，导入对方的公钥进行加密，而不要用自己的公钥加密后再把自己的私钥发送过去。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h3 id="获得公钥"><a href="#获得公钥" class="headerlink" title="获得公钥"></a>获得公钥</h3><p>你可以根据你得到的信息在任何GPG 服务器上查找对应的公钥，典型的例如查看指纹（后8 位数字为钥匙号），然后根据得到的钥匙号到服务器上查找钥匙。</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gpg --keyserver <span class="built_in">keys</span>.gnupg.net --search-<span class="built_in">keys</span> &lt;<span class="built_in">key</span> ID&gt;</span><br></pre></td></tr></table></figure>
<p>选择对应的编号，会自动下载并导入该公钥。你也可以根据用户名和邮箱进行查找。</p>
<h3 id="设置信任"><a href="#设置信任" class="headerlink" title="设置信任"></a>设置信任</h3><p>导入后的公钥需要设置信任度才能使用该公钥进行验证，你可以通过类似下面的指令编辑该公钥的信息。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gpg --<span class="keyword">edit</span>-<span class="built_in">key</span> &lt;<span class="built_in">key</span> ID&gt;</span><br></pre></td></tr></table></figure>
<p>你所看到的应该是一个文本交互界面，下面是一个样例。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gpg (GnuPG) <span class="number">2.1</span>.<span class="number">11</span>; Copyright (C) <span class="number">2016</span> Free Software Foundation, Inc.</span><br><span class="line">This <span class="keyword">is</span> free software: you are free <span class="keyword">to</span> change <span class="keyword">and</span> redistribute <span class="literal">it</span>.</span><br><span class="line">There <span class="keyword">is</span> NO WARRANTY, <span class="keyword">to</span> the extent permitted <span class="keyword">by</span> law.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pub  rsa4096/B66CC194</span><br><span class="line">     创建于：<span class="number">2016</span>-<span class="number">04</span>-<span class="number">15</span>  有效至：永不过期  可用于：SC</span><br><span class="line">     信任度：未知        有效性：未知</span><br><span class="line">sub  rsa4096/F96E3CB7</span><br><span class="line">     创建于：<span class="number">2016</span>-<span class="number">04</span>-<span class="number">15</span>  有效至：永不过期  可用于：E</span><br><span class="line">[ 未知 ] (<span class="number">1</span>). Arondight &lt;shell_way@foxmail.com&gt;</span><br><span class="line"></span><br><span class="line">gpg&gt;</span><br></pre></td></tr></table></figure>
<p>你可以键入<code>fpr</code> 来打印这个主钥的指纹，和你得到的主钥指纹进行对比，如果一致则键入<code>trust</code> 来设置主钥的信任度。如果主钥被设置为绝对可信的（ultimately），GPG 会根据主钥的公钥验证从钥的签名，最终完成信任建立。最后键入<code>quit</code> 退出。</p>
<h3 id="验证签名"><a href="#验证签名" class="headerlink" title="验证签名"></a>验证签名</h3><p>现在你可以用导入的公钥来验证你<code>git clone</code> 下来的仓库的提交和标签了，同样你需要首先告诉Git 应该使用哪个公钥对这个仓库进行验证。一般来说不同作者的项目公钥都不同，建议不要将用于验证的公钥设置为全局。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config <span class="keyword">user</span>.signingkey <span class="variable">&lt;key ID&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后可以像下面这样验证一个提交。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git verify-<span class="keyword">commit</span> &lt;<span class="keyword">commit</span> <span class="keyword">ID</span>&gt;</span><br></pre></td></tr></table></figure>
<p>或者验证一个标签。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">-v</span> <span class="tag">&lt;tag&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="签名和验证"><a href="#签名和验证" class="headerlink" title="签名和验证"></a>签名和验证</h3><table>
<thead>
<tr>
<th>动作</th>
<th>指令</th>
</tr>
</thead>
<tbody>
<tr>
<td>二进制方式签名文件</td>
<td><code>gpg -u &lt;key ID&gt; -s &lt;file&gt;</code></td>
</tr>
<tr>
<td>纯文本方式签名文件</td>
<td><code>gpg -u &lt;key ID&gt; --clearsign &lt;file&gt;</code></td>
</tr>
<tr>
<td>签名文件并独立存放签名</td>
<td><code>gpg -u &lt;key ID&gt; --detach-sign &lt;file&gt;</code></td>
</tr>
<tr>
<td>验证文件</td>
<td><code>gpg --verify-files &lt;file&gt;</code></td>
</tr>
<tr>
<td>通过独立的签名文件验证文件</td>
<td><code>gpg --verify-files &lt;file_sig&gt; &lt;file&gt;</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>如果不指定<code>-u</code> 选项，会使用第一个密钥环中主钥的私钥进行签名。</p>
</blockquote>
<h3 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h3><table>
<thead>
<tr>
<th>动作</th>
<th>指令</th>
</tr>
</thead>
<tbody>
<tr>
<td>二进制方式加密文件</td>
<td><code>gpg -r &lt;key ID&gt; -e &lt;file&gt;</code></td>
</tr>
<tr>
<td>纯文本方式加密文件</td>
<td><code>gpg -r &lt;key ID&gt; -a -e &lt;file&gt;</code></td>
</tr>
<tr>
<td>解密文件</td>
<td><code>gpg &lt;file&gt;</code></td>
</tr>
</tbody>
</table>
<blockquote>
<ol>
<li>这里你需要指定从钥的钥匙号，如果<code>-r</code> 选项被省略，GPG 会交互式的请求一个钥匙号。</li>
<li>如果你想在加密的同时签名文件，在加密指令中额外指定一个<code>-s</code> 选项。</li>
</ol>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[计算IP、ICMP、TCP和UDP包的校验和]]></title>
      <url>https://arondight.github.io/2016/03/22/%E8%AE%A1%E7%AE%97IP%E3%80%81ICMP%E3%80%81TCP%E5%92%8CUDP%E5%8C%85%E7%9A%84%E6%A0%A1%E9%AA%8C%E5%92%8C/</url>
      <content type="html"><![CDATA[<h2 id="校验和算法"><a href="#校验和算法" class="headerlink" title="校验和算法"></a>校验和算法</h2><p>校验和的计算方法在文档<a href="https://tools.ietf.org/html/rfc1071" target="_blank" rel="external">RFC 1071</a> 中有如下说明：</p>
<blockquote>
<p>(1)  Adjacent octets to be checksummed are paired to form 16-bit<br>     integers, and the 1’s complement sum of these 16-bit integers is<br>     formed.</p>
<p>(2)  To generate a checksum, the checksum field itself is cleared,<br>     the 16-bit 1’s complement sum is computed over the octets<br>     concerned, and the 1’s complement of this sum is placed in the<br>     checksum field.</p>
</blockquote>
<a id="more"></a>
<p>即首先将校验和字段清零，将待求和数据调整为偶数字节（如为奇数字节则最后一个字节扩展为字）。然后用反码相加法（进位加到低位上）、以字为单位累加待求和数据。最后将累加结果取反并截低16 位作为校验和。</p>
<blockquote>
<p>之所以使用反码相加法，是为了让计算结果和网络序或主机序无关。</p>
</blockquote>
<p>根据这个规则，计算校验和的的C 语言函数可以做如下实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint16_t</span></span><br><span class="line">GetChecksum (<span class="keyword">const</span> <span class="keyword">void</span> * <span class="keyword">const</span> addr, <span class="keyword">const</span> <span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint16_t</span> *word;</span><br><span class="line">  <span class="keyword">uint32_t</span> sum;</span><br><span class="line">  <span class="keyword">uint16_t</span> checksum;</span><br><span class="line">  <span class="keyword">size_t</span> nleft;</span><br><span class="line"></span><br><span class="line">  assert (addr);</span><br><span class="line">  assert (bytes &gt; <span class="number">8</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  word = (<span class="keyword">const</span> <span class="keyword">uint16_t</span> *)addr;</span><br><span class="line">  nleft = bytes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 使用32 位累加器，顺序累加16 位数据，进位保存在高16 位 */</span></span><br><span class="line">  <span class="keyword">for</span> (sum = <span class="number">0</span>; nleft &gt; <span class="number">1</span>; nleft -=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      sum += *word;</span><br><span class="line">      ++word;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果总字节为奇数则处理最后一个字节 */</span></span><br><span class="line">  sum += nleft ? *(<span class="keyword">uint8_t</span> *)word : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将进位加到低16 位，并将本次计算产生的进位再次加到低16 位 */</span></span><br><span class="line">  sum = (sum &gt;&gt; <span class="number">16</span>) + (sum &amp; <span class="number">0xffff</span>);</span><br><span class="line">  sum += (sum &gt;&gt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 结果取反并截低16 位为校验和 */</span></span><br><span class="line">  <span class="keyword">return</span> checksum = ~sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面会使用这个校验和计算函数分别计算IP、ICMP、TCP和UDP 包的校验和。</p>
<h2 id="IP-包校验和的计算"><a href="#IP-包校验和的计算" class="headerlink" title="IP 包校验和的计算"></a>IP 包校验和的计算</h2><p>IP 包校验和的计算范围在<a href="https://tools.ietf.org/html/rfc791" target="_blank" rel="external">RFC 791</a> 中有如下说明：</p>
<blockquote>
<p>   The checksum field is the 16 bit one’s complement of the one’s<br>   complement sum of all 16 bit words in the header.  For purposes of<br>   computing the checksum, the value of the checksum field is zero.</p>
</blockquote>
<p>即IP 包的校验和只计算包头。</p>
<p>根据描述，IP 包的校验和可用C 语言做如下计算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> iphdr *ipheader;</span><br><span class="line"></span><br><span class="line">ipheader = (<span class="keyword">struct</span> iphdr *)packet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 填充ipheader... */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算该IP 包校验和 */</span></span><br><span class="line">ipheader-&gt;check = <span class="number">0</span>;</span><br><span class="line">ipheader-&gt;check = GetChecksum (ipheader, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> iphdr));</span><br></pre></td></tr></table></figure>
<h2 id="ICMP-包校验和的计算"><a href="#ICMP-包校验和的计算" class="headerlink" title="ICMP 包校验和的计算"></a>ICMP 包校验和的计算</h2><p>ICMP 包校验和的计算范围在<a href="https://tools.ietf.org/html/rfc792" target="_blank" rel="external">RFC 792</a> 中有如下说明：</p>
<blockquote>
<p>   The checksum is the 16-bit ones’s complement of the one’s<br>   complement sum of the ICMP message starting with the ICMP Type.<br>   For computing the checksum , the checksum field should be zero.<br>   This checksum may be replaced in the future.</p>
</blockquote>
<p>即ICMP 包的计算范围包括包头和数据。</p>
<p>根据描述，假设IP 包校验和已经计算完毕，那么其中的ICMP 包校验和可以用C 语言做如下计算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> icmphdr *icmpheader;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> ipheaderSize = <span class="keyword">sizeof</span> (<span class="keyword">struct</span> iphdr);</span><br><span class="line"></span><br><span class="line">icmpheader = (<span class="keyword">struct</span> icmphdr *)(packet + ipheaderSize);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 填充icmpheader... */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算该ICMP 包校验和 */</span></span><br><span class="line">icmpheader-&gt;checksum = <span class="number">0</span>;</span><br><span class="line">icmpheader-&gt;checksum = GetChecksum (icmpheader, packetSize - ipheaderSize);</span><br></pre></td></tr></table></figure>
<h2 id="TCP-和UDP-包校验和的计算"><a href="#TCP-和UDP-包校验和的计算" class="headerlink" title="TCP 和UDP 包校验和的计算"></a>TCP 和UDP 包校验和的计算</h2><h3 id="伪首部"><a href="#伪首部" class="headerlink" title="伪首部"></a>伪首部</h3><p>TCP 和UDP 校验和的计算要稍微麻烦一些，因为需要引入一个伪首部（pseudo header），伪首部的结构在<a href="https://tools.ietf.org/html/rfc768" target="_blank" rel="external">RFC 768</a> 中有如下说明：</p>
<blockquote>
<p> The pseudo  header  conceptually prefixed to the UDP header contains the<br> source  address,  the destination  address,  the protocol,  and the  UDP<br> length.   This information gives protection against misrouted datagrams.<br> This checksum procedure is the same as is used in TCP.</p>
<pre><code> 0      7 8     15 16    23 24    31
+--------+--------+--------+--------+
|          source address           |
+--------+--------+--------+--------+
|        destination address        |
+--------+--------+--------+--------+
|  zero  |protocol|   UDP length    |
+--------+--------+--------+--------+
</code></pre></blockquote>
<p>可见TCP 和UDP 的伪首部结构完全一致。</p>
<p>根据描述，伪首部的结构可以用C 语言结构体做如下实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> pseudohdr</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> src;</span><br><span class="line">  <span class="keyword">uint32_t</span> dst;</span><br><span class="line">  <span class="keyword">uint8_t</span> zero;</span><br><span class="line">  <span class="keyword">uint8_t</span> protocol;</span><br><span class="line">  <span class="keyword">uint16_t</span> len;</span><br><span class="line">&#125; <span class="keyword">pseudohdr_t</span>;</span><br></pre></td></tr></table></figure>
<h3 id="TCP-包校验和的计算"><a href="#TCP-包校验和的计算" class="headerlink" title="TCP 包校验和的计算"></a>TCP 包校验和的计算</h3><p>TCP 包校验和的计算方法在<a href="https://tools.ietf.org/html/rfc793" target="_blank" rel="external">RFC 793</a> 中有如下说明：</p>
<blockquote>
<p> The checksum field is the 16 bit one’s complement of the one’s<br> complement sum of all 16 bit words in the header and text.  If a<br> segment contains an odd number of header and text octets to be<br> checksummed, the last octet is padded on the right with zeros to<br> form a 16 bit word for checksum purposes.  The pad is not<br> transmitted as part of the segment.  While computing the checksum,<br> the checksum field itself is replaced with zeros.</p>
<p>   The checksum also covers a 96 bit pseudo header conceptually</p>
</blockquote>
<p>可见，算法和之前提到的校验和算法完全一致，根据描述校验和的计算需要包含伪首部和整个TCP 包。</p>
<p>根据描述，假设IP 包校验和已经计算完毕，那么其中的TCP 包校验和可以用C 语言做如下计算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *tcpsumblock;          <span class="comment">/* 伪首部 + TCP 头 + 数据 */</span></span><br><span class="line"><span class="keyword">struct</span> iphdr *ipheader;</span><br><span class="line"><span class="keyword">struct</span> tcphdr *tcpheader;</span><br><span class="line"><span class="keyword">pseudohdr_t</span> pseudoheader;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> ipheaderSize = (<span class="keyword">struct</span> iphdr *)packet;</span><br><span class="line"></span><br><span class="line">ipheader = (<span class="keyword">struct</span> iphdr *)packet;</span><br><span class="line">tcpheader = (<span class="keyword">struct</span> tcphdr *)(packet + ipheaderSize);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 填充tcpheader... */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 填充pseudoheader */</span></span><br><span class="line">pseudoheader.src = ipheader-&gt;saddr;</span><br><span class="line">pseudoheader.dst = ipheader-&gt;daddr;</span><br><span class="line">pseudoheader.zero = <span class="number">0</span>;</span><br><span class="line">pseudoheader.protocol = ipheader-&gt;protocol;</span><br><span class="line">pseudoheader.len = htons (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> tcphdr));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 填充tcpsumblock */</span></span><br><span class="line">tcpheader-&gt;check = <span class="number">0</span>;</span><br><span class="line">tcpsumblock = (<span class="keyword">char</span> *)<span class="built_in">malloc</span> (packetSize);</span><br><span class="line"><span class="built_in">memcpy</span> (tcpsumblock, &amp;pseudoheader, <span class="keyword">sizeof</span> (<span class="keyword">pseudohdr_t</span>));</span><br><span class="line"><span class="built_in">memcpy</span> (tcpsumblock + <span class="keyword">sizeof</span> (<span class="keyword">pseudohdr_t</span>), packet, packetSize);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算TCP 包校验和 */</span></span><br><span class="line">tcpheader-&gt;check =</span><br><span class="line">  GetChecksum (tcpsumblock, <span class="keyword">sizeof</span> (<span class="keyword">pseudohdr_t</span>) + packetSize - ipheaderSize);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span> (tcpsumblock);</span><br><span class="line">tcpsumblock = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<h3 id="UDP-包校验和的计算"><a href="#UDP-包校验和的计算" class="headerlink" title="UDP 包校验和的计算"></a>UDP 包校验和的计算</h3><p>UDP 包校验和的计算方法在<a href="https://tools.ietf.org/html/rfc768" target="_blank" rel="external">RFC 768</a> 中有如下说明：</p>
<blockquote>
<p> Checksum is the 16-bit one’s complement of the one’s complement sum of a<br> pseudo header of information from the IP header, the UDP header, and the<br> data,  padded  with zero octets  at the end (if  necessary)  to  make  a<br> multiple of two octets.</p>
<p>The pseudo  header  conceptually prefixed to the UDP header contains the<br>source  address,  the destination  address,  the protocol,  and the  UDP<br>length.   This information gives protection against misrouted datagrams.<br>This checksum procedure is the same as is used in TCP.</p>
</blockquote>
<p>所以UDP 包校验和的计算方法和TCP 包如出一辙，同样包含了一个伪首部。</p>
<p>具体的实现可以参考之前计算TCP 包校验的C 语言实现。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用SSH反向隧道进行内网穿透]]></title>
      <url>https://arondight.github.io/2016/02/17/%E4%BD%BF%E7%94%A8SSH%E5%8F%8D%E5%90%91%E9%9A%A7%E9%81%93%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
      <content type="html"><![CDATA[<h2 id="对应的情况"><a href="#对应的情况" class="headerlink" title="对应的情况"></a>对应的情况</h2><p>这篇文章主要介绍了如何利用SSH 反向隧道穿透NAT，并演示了如何维持一条稳定的SSH 隧道。</p>
<p>假设有机器A 和B，A 有公网IP，B 位于NAT 之后并无可用的端口转发，现在想由A 主动向B 发起SSH 连接。由于B 在NAT 后端，无可用<strong>公网IP + 端口</strong> 这样一个组合，所以A 无法穿透NAT，这篇文章应对的就是这种情况。</p>
<p>首先有如下约定，因为很重要所以放在前面：</p>
<table>
<thead>
<tr>
<th>机器代号</th>
<th>机器位置</th>
<th>地址</th>
<th>账户</th>
<th>ssh/sshd 端口</th>
<th>是否需要运行sshd</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>位于公网</td>
<td>a.site</td>
<td>usera</td>
<td>22</td>
<td>是</td>
</tr>
<tr>
<td>B</td>
<td>位于NAT 之后</td>
<td>127.0.0.1</td>
<td>userb</td>
<td>22</td>
<td>是</td>
</tr>
<tr>
<td>C</td>
<td>位于NAT 之后</td>
<td>127.0.0.1</td>
<td>userc</td>
<td>22</td>
<td>否</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<blockquote>
<p>这里默认你的系统init 程序为<code>systemd</code>，如果你使用其他的init 程序，如果没有特殊理由还是换到一个现代化的GNU/Linux 系统吧……</p>
</blockquote>
<h2 id="SSH-反向隧道"><a href="#SSH-反向隧道" class="headerlink" title="SSH 反向隧道"></a>SSH 反向隧道</h2><p>这种手段实质上是由B 向A 主动地建立一个SSH 隧道，将A 的6766 端口转发到B 的22 端口上，只要这条隧道不关闭，这个转发就是有效的。有了这个端口转发，只需要访问A 的6766 端口反向连接B 即可。</p>
<p>首先在<strong>B</strong> 上建立一个SSH 隧道，将A 的6766 端口转发到B 的22 端口上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B $ ssh -p 22 -qngfNTR 6766:127.0.0.1:22 usera@a.site</span><br></pre></td></tr></table></figure>
<p>然后在<strong>A</strong> 上利用6766 端口反向SSH 到B：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A $ ssh -p 6766 userb@127.0.0.1</span><br></pre></td></tr></table></figure>
<p>要做的事情其实就是这么简单。</p>
<h2 id="隧道的维持"><a href="#隧道的维持" class="headerlink" title="隧道的维持"></a>隧道的维持</h2><h3 id="稳定性维持"><a href="#稳定性维持" class="headerlink" title="稳定性维持"></a>稳定性维持</h3><p>然而不幸的是SSH 连接是会超时关闭的，如果连接关闭，隧道无法维持，那么A 就无法利用反向隧道穿透B 所在的NAT 了，为此我们需要一种方案来提供一条稳定的SSH 反向隧道。</p>
<p>一个最简单的方法就是<code>autossh</code>，这个软件会在超时之后自动重新建立SSH 隧道，这样就解决了隧道的稳定性问题，如果你使用<a href="https://www.archlinux.org" target="_blank" rel="external">Arch Linux</a>，你可以这样获得它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pacman -S autossh</span><br></pre></td></tr></table></figure>
<p>下面在<strong>B</strong> 上做之前类似的事情，不同的是该隧道会由<code>autossh</code> 来维持：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B $ autossh -p 22 -M 6777 -NR 6766:127.0.0.1:22 usera@a.site</span><br></pre></td></tr></table></figure>
<p><code>-M</code> 参数指定的端口用来监听隧道的状态，与端口转发无关。</p>
<p>之后你可以在A 上通过6766 端口访问B 了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A $ ssh -p 6766 userb@127.0.0.1</span><br></pre></td></tr></table></figure>
<h3 id="隧道的自动建立"><a href="#隧道的自动建立" class="headerlink" title="隧道的自动建立"></a>隧道的自动建立</h3><p>然而这又有了另外一个问题，如果B 重启隧道就会消失。那么需要有一种手段在B 每次启动时使用<code>autossh</code> 来建立SSH 隧道。很自然的一个想法就是做成服务，之后会给出在<code>systemd</code> 下的一种解决方案。</p>
<h2 id="“打洞”"><a href="#“打洞”" class="headerlink" title="“打洞”"></a>“打洞”</h2><p>之所以标题这么起，是因为自己觉得这件事情有点类似于UDP 打洞，即通过一台在公网的机器，让两台分别位于各自NAT 之后的机器可以建立SSH 连接。</p>
<p>下面演示如何使用SSH 反向隧道，让C 连接到B。</p>
<p>首先在<strong>A</strong> 上编辑<code>sshd</code> 的配置文件<code>/etc/ssh/sshd_config</code>，将<code>GatewayPorts</code> 开关打开：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">GatewayPorts</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure>
<p>然后重启<code>sshd</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A $ sudo systemctl restart sshd</span><br></pre></td></tr></table></figure>
<p>然后在<strong>B</strong> 上对之前用到的<code>autossh</code> 指令略加修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B $ autossh -p 22 -M 6777 -NR <span class="string">'*:6766:127.0.0.1:22'</span> usera@a.site</span><br></pre></td></tr></table></figure>
<p>之后在<strong>C</strong> 上利用<strong>A</strong> 的6766 端口SSH 连接到<strong>B</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C $ ssh -p 6766 userb@a.site</span><br></pre></td></tr></table></figure>
<p>至此你已经轻而易举的穿透了两层NAT。</p>
<h2 id="最终的解决方案"><a href="#最终的解决方案" class="headerlink" title="最终的解决方案"></a>最终的解决方案</h2><p>整合一下前面提到的，最终的解决方案如下：</p>
<p>首先打开<strong>A</strong> 上<code>sshd</code> 的<code>GatewayPorts</code> 开关，并重启<code>sshd</code>（如有需要）。</p>
<p>然后在<strong>B</strong> 上新建一个用户<em>autossh</em>，根据权限最小化思想，B 上的<code>autossh</code> 服务将以<em>autossh</em> 用户的身份运行，以尽大可能避免出现安全问题：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B $ sudo useradd -m autossh</span><br><span class="line">B $ sudo passwd autossh</span><br></pre></td></tr></table></figure>
<p>紧接着在<strong>B</strong> 上为<em>autossh</em> 用户创建SSH 密钥，并上传到A：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B $ su - autossh</span><br><span class="line">B $ ssh-keygen -t <span class="string">'rsa'</span> -C <span class="string">'autossh@B'</span></span><br><span class="line">B $ ssh-copy-id usera@a.site</span><br></pre></td></tr></table></figure>
<p>注意该<strong>密钥不要设置密码</strong>，也就是运行<code>ssh-keygen</code> 指令时尽管一路回车，不要输入额外的字符。</p>
<p>然后在<strong>B</strong> 上创建以<em>autossh</em> 用户权限调用<code>autossh</code> 的service 文件。将下面文本写入到文件<code>/lib/systemd/system/autossh.service</code>，并设置权限为644：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Auto SSH Tunnel</span><br><span class="line"><span class="attr">After</span>=network-<span class="literal">on</span>line.target</span><br><span class="line"><span class="section"></span><br><span class="line">[Service]</span></span><br><span class="line"><span class="attr">User</span>=autossh</span><br><span class="line"><span class="attr">Type</span>=simple</span><br><span class="line"><span class="attr">ExecStart</span>=/bin/autossh -p <span class="number">22</span> -M <span class="number">6777</span> -NR <span class="string">'*:6766:127.0.0.1:22'</span> usera@a.site -i /home/autossh/.ssh/id_rsa</span><br><span class="line"><span class="attr">ExecReload</span>=/bin/kill -HUP <span class="variable">$MAINPID</span></span><br><span class="line"><span class="attr">KillMode</span>=process</span><br><span class="line"><span class="attr">Restart</span>=always</span><br><span class="line"><span class="section"></span><br><span class="line">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br><span class="line"><span class="attr">WantedBy</span>=graphical.target</span><br></pre></td></tr></table></figure>
<p>在<strong>B</strong> 上设置该服务自动启动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B $ sudo systemctl <span class="built_in">enable</span> autossh</span><br></pre></td></tr></table></figure>
<p>如果你愿意，在这之后可以立刻启动它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B $ sudo systemctl start autossh</span><br></pre></td></tr></table></figure>
<p>然后你可以在<strong>A</strong> 上使用这条反向隧道穿透B 所在的NAT SSH 连接到B：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A $ ssh -p 6766 userb@127.0.0.1</span><br></pre></td></tr></table></figure>
<p>或者是在<strong>C</strong> 上直接穿透两层NAT SSH 连接到B：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C $ ssh -p 6766 userb@a.site</span><br></pre></td></tr></table></figure>
<p>如果你对SSH 足够熟悉，你可以利用这条隧道做更多的事情，例如你可以在反向连接时指定动态端口转发：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C $ ssh -p 6766 -qngfNTD 7677 userb@a.site</span><br></pre></td></tr></table></figure>
<p>假设<strong>C</strong> 是你家中的电脑，<strong>A</strong> 是你的VPS，<strong>B</strong> 是你公司的电脑。如果你这样做了，那么为浏览器设置端口为<code>7677</code> 的<code>sock4</code> 本地（127.0.0.1）代理后，你就可以在家里的浏览器上看到公司内网的网页。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[新年快乐]]></title>
      <url>https://arondight.github.io/2016/02/08/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90/</url>
      <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="comment"># For Linux 3.10+ x86_64 and gcc 4.8+</span></span><br><span class="line">cat &lt;&lt;<span class="string">'By_Arondight'</span> | env gcc -xc -o .\ - - \</span><br><span class="line">&gt;/dev/null 2&gt;&amp;1 &amp;&amp; ./.\ - &amp;&amp; env rm .\ -</span><br><span class="line">char _[]=<span class="string">"\xe6\x96\xb0\xe5\xb9\xb4\xe5\xbf\xab\</span><br><span class="line">\xe4\xb9\x90\xef\xbc\x81\x0a"</span>;____(___)&lt;%putchar</span><br><span class="line">((___++)[_])&amp;&amp;____(___);_<span class="built_in">exit</span>(0);%&gt;main()&lt;%long</span><br><span class="line">__=____;*(&amp;__+2)=__;__asm__(<span class="string">"\x78\x6f\x72\x71\x20\</span><br><span class="line">\x25\x72\x64\x69\x2c\x20\x25\x72\x64\x69\xa\x0"</span>);%&gt;</span><br><span class="line">By_Arondight</span><br></pre></td></tr></table></figure>
<p>惟愿可以遇到美好的人和事。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[随便写一点东西]]></title>
      <url>https://arondight.github.io/2016/01/03/%E9%9A%8F%E4%BE%BF%E5%86%99%E4%B8%80%E7%82%B9%E4%B8%9C%E8%A5%BF/</url>
      <content type="html"><![CDATA[<p>下午慢慢折腾了一下Hexo，然后成果就是这个博客。老实说我也不太清楚以后究竟在这上面会写点什么，多半会是所处的日常吧。</p>
<p>折腾完大约是下午接近4 点的样子，足足搞了快5 个小时。透过窄窄的窗子所看到的已经是很惨淡的阳光了。回过神来今天已经是公历新年后的第3 天了，或许因为最近1 个半月想了很多的事情，不知不觉已经将一年最后的时间消耗殆尽，不难过也不开心。</p>
<p>因为搞乱了生活节奏的原因，难得的假期里并没有什么新年的实感，没想过什么愿望，也没制定什么计划，不过依着心里还留存的一点点向往，希望以后能收获一些好的事物吧。</p>
]]></content>
    </entry>
    
  
  
</search>
