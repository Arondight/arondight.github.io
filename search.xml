<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[为LibVirt添加新的API]]></title>
      <url>https://arondight.github.io/2016/12/25/%E4%B8%BALibVirt%E6%B7%BB%E5%8A%A0%E6%96%B0%E7%9A%84API/</url>
      <content type="html"><![CDATA[<p><a href="http://libvirt.org" target="_blank" rel="external">LibVirt</a> 是一套用于控制虚拟化的API，除了提供了一套无关具体虚拟化细节的API 之外，还提供了一个daemon（<code>libvirtd</code>) 和一个控制台工具（<code>virsh</code>）。本文演示了如何在LibVirt 中新加一个API，并且在<code>libvirtd</code> 和<code>virsh</code> 中使用新的API 完成新的功能。</p>
<p>为了方便说明，在文章的示例中只演示了添加一个API，如果要看完整的示例，可以查看项目<a href="https://github.com/Arondight/libvirt-add-new-api-demo" target="_blank" rel="external">Arondight/libvirt-add-new-api-demo</a>，这是一个相对完整的示例，项目中新API 的说明以及Patch 的使用可以参见其中的<code>README.txt</code>。</p>
<div class="github-widget" data-repo="Arondight/libvirt-add-new-api-demo"></div>

<a id="more"></a>
<h2 id="构建开发环境"><a href="#构建开发环境" class="headerlink" title="构建开发环境"></a>构建开发环境</h2><p>首先你需要有一套可以编译的LibVirt 源码，在本文的示例中我们使用了<code>v2.5.0</code> 版本的源码，你可以通过以下指令来得到它。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/libvirt/libvirt.git</div><div class="line"><span class="built_in">pushd</span> libvirt &amp;&amp; git checkout v2.5.0 &amp;&amp; <span class="built_in">popd</span></div></pre></td></tr></table></figure>
<p>LibVirt 的编译需要<a href="http://www.gnu.org/software/gnulib" target="_blank" rel="external">Gnulib</a> 的源码，不过因为网络的原因在墙内其Git 仓库很难获取，所以这里使用GitHub 上的镜像仓库，并通过环境变量引入。你可以设置好这一切并编译一遍源码。在上面的指令执行成功后执行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">clone</span> https://github.com/coreutils/gnulib.git</div><div class="line"><span class="built_in">export</span> GNULIB_SRCDIR=$(readlink <span class="_">-f</span> ./gnulib)</div><div class="line"><span class="built_in">cd</span> ./libvirt</div><div class="line">./autogen.sh</div><div class="line">make -j8</div><div class="line">make check -j8</div></pre></td></tr></table></figure>
<p>如果你的编译依赖完备的话，LibVirt 可以正确编译并通过测试。如果你没有得到预期的结果，请检查你的编译环境并安装缺失的软件包。</p>
<p>示例中我们添加的API 为<code>virConnectGetMagicFileContent</code>，功能为获取运行虚拟化的机器上某个文件内容的最多前32 个字节。</p>
<h2 id="添加公共API"><a href="#添加公共API" class="headerlink" title="添加公共API"></a>添加公共API</h2><p>首先要做的是为LibVirt 添加公共API，这个API 也是LibVirt 为用户展现的API。此后通过一连串调用，我们会在<code>libvirtd</code> 和<code>virsh</code> 中通过调用这个公共API 来完成新功能。这里需要修改的文件有如下几个。</p>
<ol>
<li><code>include/libvirt/libvirt-*.h</code>: 这里需要完成公共API 的声明，此后通过包含头文件<code>include/libvirt/libvirt.h</code> 可调用此API。</li>
<li><code>src/libvirt_public.syms</code>: 这里需要将新API 导出为全局符号，这样公共API 得以允许被其他函数访问，如果你在步骤<code>[1]</code> 中定义了一个需要被其他函数访问的数据结构，同样你也需要将它导出为全局符号。</li>
<li><code>src/libvirt-*.c</code>: 这里需要实现步骤<code>[1]</code> 中声明的API，一般来说这里只调用驱动提供的API 即可，具体功能需要在每个hypervisor 的驱动中单独实现。</li>
</ol>
<h3 id="API-的注释"><a href="#API-的注释" class="headerlink" title="API 的注释"></a>API 的注释</h3><p>首先要说明的是，公共API 必须要有合乎规范的注释。在编译时，<code>docs/apibuild.py</code> 会检查宏和公共API 的注释是否符合要求，如果发现不合格的注释，将中断整个编译过程。注释在声明和定义处皆可。</p>
<p>对于一个宏，注释的格式如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * MACRO_NAME:</div><div class="line"> *</div><div class="line"> * macro's comment.</div><div class="line"> */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MACRO_NAME (SOMETHING_HERE)</span></div></pre></td></tr></table></figure>
<p>对于一个API，注释的格式如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * apiName:</div><div class="line"> *</div><div class="line"> * @arg: arg's comment</div><div class="line"> *</div><div class="line"> * synopsis for this api.</div><div class="line"> *</div><div class="line"> * Returns what.</div><div class="line"> */</div><div class="line"><span class="function">ret_type</span></div><div class="line"><span class="title">apiName</span><span class="params">(arg_type arg)</span> &#123; &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：API 注释中的单词<code>Returns</code> 标明了这是返回值的注释，不能随意修改。</p>
</blockquote>
<h3 id="声明公共API"><a href="#声明公共API" class="headerlink" title="声明公共API"></a>声明公共API</h3><p>目录<code>include/libvirt</code> 下有众多以<code>libvirt-</code> 开头的头文件，公共API 分散在其中。因为新的API 返回在运行虚拟化的主机上某个文件的某段内容，所以我们在头文件<code>include/libvirt/libvirt-host.h</code> 声明这个API。</p>
<figure class="highlight patch"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">diff --git a/include/libvirt/libvirt-host.h b/include/libvirt/libvirt-host.h</div><div class="line">index 07b5d1594..72db263d2 100644</div><div class="line"><span class="comment">--- a/include/libvirt/libvirt-host.h</span></div><div class="line"><span class="comment">+++ b/include/libvirt/libvirt-host.h</span></div><div class="line">@@ -686,5 +686,27 @@ int virNodeAllocPages(virConnectPtr conn,</div><div class="line">                       unsigned int cellCount,</div><div class="line">                       unsigned int flags);</div><div class="line"></div><div class="line"><span class="addition">+/**</span></div><div class="line"><span class="addition">+ * VIR_CONNECT_MAGIC_FILE_PATH:</span></div><div class="line"><span class="addition">+ *</span></div><div class="line"><span class="addition">+ * This is the absolute path of file.</span></div><div class="line"><span class="addition">+ */</span></div><div class="line"><span class="addition">+#define VIR_CONNECT_MAGIC_FILE_PATH ("/var/run/libvirt/magic_file")</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+/**</span></div><div class="line"><span class="addition">+ * VIR_CONNECT_MAGIC_FILE_FORBIDDEN_STR:</span></div><div class="line"><span class="addition">+ *</span></div><div class="line"><span class="addition">+ * If file's content match this, qemu driver will refused to boot VM</span></div><div class="line"><span class="addition">+ */</span></div><div class="line"><span class="addition">+#define VIR_CONNECT_MAGIC_FILE_FORBIDDEN_STR ("0xabadcafe")</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+/**</span></div><div class="line"><span class="addition">+ * VIR_CONNECT_MAGIC_FILE_CONTENT_LEN:</span></div><div class="line"><span class="addition">+ *</span></div><div class="line"><span class="addition">+ * Max length of file.</span></div><div class="line"><span class="addition">+ */</span></div><div class="line"><span class="addition">+#define VIR_CONNECT_MAGIC_FILE_CONTENT_LEN (32)</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+char *virConnectGetMagicFileContent(virConnectPtr conn);</span></div><div class="line"></div><div class="line"> #endif /* __VIR_LIBVIRT_HOST_H__ */</div></pre></td></tr></table></figure>
<p>这个Patch 做的事情非常简单：定义了三个以后会用到的宏，并且声明了公共API。因为这个功能需要访问远程主机上的文件，所以公共API 需要一个参数<code>virConnectPtr</code>，通过这个指针我们可以调用具体的remote 或hypervisor 驱动（前者用于远程调用，后者是真正操纵虚拟化的驱动，例如QEMU 驱动）。</p>
<p>除了这个文件以外，还需要将公共API 在<code>src/libvirt_public.syms</code> 中导出。</p>
<figure class="highlight patch"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">diff --git a/src/libvirt_public.syms b/src/libvirt_public.syms</div><div class="line">index e01604cad..4db27dc2b 100644</div><div class="line"><span class="comment">--- a/src/libvirt_public.syms</span></div><div class="line"><span class="comment">+++ b/src/libvirt_public.syms</span></div><div class="line">@@ -746,4 +746,9 @@ LIBVIRT_2.2.0 &#123;</div><div class="line">         virConnectNodeDeviceEventDeregisterAny;</div><div class="line"> &#125; LIBVIRT_2.0.0;</div><div class="line"></div><div class="line"><span class="addition">+LIBVIRT_2.5.0 &#123;</span></div><div class="line"><span class="addition">+    global:</span></div><div class="line"><span class="addition">+        virConnectGetMagicFileContent;</span></div><div class="line"><span class="addition">+&#125; LIBVIRT_2.2.0;</span></div><div class="line"><span class="addition">+</span></div><div class="line"> # .... define new API here using predicted next version number ....</div></pre></td></tr></table></figure>
<p>完成这一步工作之后，新的公共API 就可以被其他的函数所调用。</p>
<h3 id="实现公共API"><a href="#实现公共API" class="headerlink" title="实现公共API"></a>实现公共API</h3><p>对应头文件<code>include/libvirt/libvirt-host.h</code>，我们需要在文件<code>src/libvirt-host.c</code> 中实现新API。</p>
<figure class="highlight patch"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">diff --git a/src/libvirt-host.c b/src/libvirt-host.c</div><div class="line">index 335798abf..0b8b41ca9 100644</div><div class="line"><span class="comment">--- a/src/libvirt-host.c</span></div><div class="line"><span class="comment">+++ b/src/libvirt-host.c</span></div><div class="line">@@ -1482,3 +1482,36 @@ virNodeAllocPages(virConnectPtr conn,</div><div class="line">     virDispatchError(conn);</div><div class="line">     return -1;</div><div class="line"> &#125;</div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+/**</span></div><div class="line"><span class="addition">+ * virConnectGetMagicFileContent:</span></div><div class="line"><span class="addition">+ *</span></div><div class="line"><span class="addition">+ * @conn: virConnect connection</span></div><div class="line"><span class="addition">+ *</span></div><div class="line"><span class="addition">+ * Get content of magic file, max length is VIR_CONNECT_MAGIC_FILE_CONTENT_LEN.</span></div><div class="line"><span class="addition">+ *</span></div><div class="line"><span class="addition">+ * Returns content of file if all succeed or NULL upon any failure.</span></div><div class="line"><span class="addition">+ */</span></div><div class="line"><span class="addition">+char *</span></div><div class="line"><span class="addition">+virConnectGetMagicFileContent(virConnectPtr conn)</span></div><div class="line"><span class="addition">+&#123;</span></div><div class="line"><span class="addition">+    VIR_DEBUG("conn=%p", conn);</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+    virResetLastError();</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+    virCheckConnectReturn(conn, NULL);</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+    if (conn-&gt;driver-&gt;connectGetMagicFileContent) &#123;</span></div><div class="line"><span class="addition">+        char *ret = conn-&gt;driver-&gt;connectGetMagicFileContent(conn);</span></div><div class="line"><span class="addition">+        if (!ret)</span></div><div class="line"><span class="addition">+            goto error;</span></div><div class="line"><span class="addition">+        return ret;</span></div><div class="line"><span class="addition">+    &#125;</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+    virReportUnsupportedError();</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+ error:</span></div><div class="line"><span class="addition">+    virDispatchError(conn);</span></div><div class="line"><span class="addition">+    return NULL;</span></div><div class="line"><span class="addition">+&#125;</span></div></pre></td></tr></table></figure>
<p>在这个Patch 里我们虽然实现了公共API，但是没有在其中做具体的操作，而是根据参数<code>conn</code> 调用了驱动<code>connectGetMagicFileContent</code>，具体的工作将由该驱动完成。现在我们无法直接判断该驱动是一个reomte 驱动还是hypervisor 驱动，通常来说如果你正在使用一个运行<code>libvirtd</code> 的远程主机，那么此处将是一个remote 驱动，否则将会直接调用hypervisor 驱动。</p>
<blockquote>
<p>到现在为止，假设我们使用<code>virsh get-magic</code> 在标准输出上打印出文件的内容时，函数的调用链如下（假设直接调用hypervisor 驱动）。以后每一部分的工作结束后，我们都将重新整理这个调用链以方便理清我们都做了什么。</p>
<p>??? -&gt; <code>virConnectGetMagicFileContent</code>@LibVirt -&gt; <code>connectGetMagicFileContent</code>@hypervisor -&gt; ???</p>
</blockquote>
<h2 id="实现hypervisor-驱动"><a href="#实现hypervisor-驱动" class="headerlink" title="实现hypervisor 驱动"></a>实现hypervisor 驱动</h2><p>LibVirt 可用的hypervisor 有很多，这里我们只为最常用的QEMU 编写驱动。</p>
<h3 id="添加内部驱动API"><a href="#添加内部驱动API" class="headerlink" title="添加内部驱动API"></a>添加内部驱动API</h3><p>因为LibVirt 在用户层面上提供了统一的API，而这个公共API 调用了一个确定的驱动API。因此我们需要在<code>src/driver-hypervisor.h</code> 中确定这个API 以提供给公共API 调用。后面我们会用到几个结构体变量将这个统一的驱动API 和具体的hypervisor 驱动函数关联起来，然后在hypervisor 驱动中具体的实现它，从而提供无关虚拟化细节的API。</p>
<figure class="highlight patch"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">diff --git a/src/driver-hypervisor.h b/src/driver-hypervisor.h</div><div class="line">index 51af73200..78de6b04a 100644</div><div class="line"><span class="comment">--- a/src/driver-hypervisor.h</span></div><div class="line"><span class="comment">+++ b/src/driver-hypervisor.h</span></div><div class="line">@@ -1251,6 +1251,9 @@ typedef int</div><div class="line">                              int state,</div><div class="line">                              unsigned int flags);</div><div class="line"></div><div class="line"><span class="addition">+typedef char *</span></div><div class="line"><span class="addition">+(*virDrvConnectGetMagicFileContent)(virConnectPtr conn);</span></div><div class="line"><span class="addition">+</span></div><div class="line"> typedef struct _virHypervisorDriver virHypervisorDriver;</div><div class="line"> typedef virHypervisorDriver *virHypervisorDriverPtr;</div><div class="line"></div><div class="line">@@ -1489,6 +1492,7 @@ struct _virHypervisorDriver &#123;</div><div class="line">     virDrvDomainMigrateStartPostCopy domainMigrateStartPostCopy;</div><div class="line">     virDrvDomainGetGuestVcpus domainGetGuestVcpus;</div><div class="line">     virDrvDomainSetGuestVcpus domainSetGuestVcpus;</div><div class="line"><span class="addition">+    virDrvConnectGetMagicFileContent connectGetMagicFileContent;</span></div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<p>这里我们声明了一个<code>virDrvConnectGetMagicFileContent</code> 类型的函数指针变量，并添加到了结构体类型<code>_virHypervisorDriver</code> 的声明当中，下面在QEMU 驱动中我们会将这个函数指针指向具体的驱动函数。从而完成LibVirt API 到QEMU 驱动函数的调用。</p>
<h3 id="添加hypervisor-公共API"><a href="#添加hypervisor-公共API" class="headerlink" title="添加hypervisor 公共API"></a>添加hypervisor 公共API</h3><p>现在我们只需实现QEMU 的驱动函数，并在结构体变量<code>qemuHypervisorDriver</code> 中用新的驱动函数为上一节新加的函数指针赋值即可。这样虽然各个hypervisor 的驱动细节各不相同，但是在LibVirt 上却表现为一致的接口，从而为用于隐藏了具体的虚拟化细节。</p>
<p>注意通常来说驱动具体的功能并不在此实现，而是在<code>qemu/qemu_capabilities.h</code> 中提供一个QEMU 驱动内可见的API，并在<code>qemu/qemu_capabilities.c</code> 中通过一系列函数调用完成驱动的具体功能。</p>
<figure class="highlight patch"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">diff --git a/src/qemu/qemu_driver.c b/src/qemu/qemu_driver.c</div><div class="line">index 3517aa2be..4e108e96a 100644</div><div class="line"><span class="comment">--- a/src/qemu/qemu_driver.c</span></div><div class="line"><span class="comment">+++ b/src/qemu/qemu_driver.c</span></div><div class="line">@@ -20273,6 +20273,31 @@ qemuDomainSetGuestVcpus(virDomainPtr dom,</div><div class="line"> &#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="addition">+static char *</span></div><div class="line"><span class="addition">+qemuConnectGetMagicFileContent(virConnectPtr conn)</span></div><div class="line"><span class="addition">+&#123;</span></div><div class="line"><span class="addition">+    virQEMUDriverPtr driver = conn-&gt;privateData;</span></div><div class="line"><span class="addition">+    char *ret = NULL;</span></div><div class="line"><span class="addition">+    virCapsPtr caps = NULL;</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+    if (virConnectGetMagicFileContentEnsureACL (conn) &lt; 0) &#123;</span></div><div class="line"><span class="addition">+        return NULL;</span></div><div class="line"><span class="addition">+    &#125;</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+    if (!(caps = virQEMUDriverGetCapabilities(driver, false))) &#123;</span></div><div class="line"><span class="addition">+        goto cleanup;</span></div><div class="line"><span class="addition">+    &#125;</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+    if (!(ret = virQEMUCapsGetMagicFileContent(caps))) &#123;</span></div><div class="line"><span class="addition">+        goto cleanup;</span></div><div class="line"><span class="addition">+    &#125;</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+ cleanup:</span></div><div class="line"><span class="addition">+    virObjectUnref(caps);</span></div><div class="line"><span class="addition">+    return ret;</span></div><div class="line"><span class="addition">+&#125;</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+</span></div><div class="line"> static virHypervisorDriver qemuHypervisorDriver = &#123;</div><div class="line">     .name = QEMU_DRIVER_NAME,</div><div class="line">     .connectOpen = qemuConnectOpen, /* 0.2.0 */</div><div class="line">@@ -20486,6 +20511,7 @@ static virHypervisorDriver qemuHypervisorDriver = &#123;</div><div class="line">     .domainMigrateStartPostCopy = qemuDomainMigrateStartPostCopy, /* 1.3.3 */</div><div class="line">     .domainGetGuestVcpus = qemuDomainGetGuestVcpus, /* 2.0.0 */</div><div class="line">     .domainSetGuestVcpus = qemuDomainSetGuestVcpus, /* 2.0.0 */</div><div class="line"><span class="addition">+    .connectGetMagicFileContent = qemuConnectGetMagicFileContent, /* 2.5.0 */</span></div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<p>这里用到一个权限检查函数<code>virConnectGetMagicFileContentEnsureACL</code>，目前为止我们还没见过它，而它将在我们编写remote 驱动时由<code>src/rpc/gendispatch.pl</code> 生成。</p>
<h3 id="完成hypervisor-驱动的功能"><a href="#完成hypervisor-驱动的功能" class="headerlink" title="完成hypervisor 驱动的功能"></a>完成hypervisor 驱动的功能</h3><p>现在我们可以在<code>src/qemu/qemu_capabilities.c</code> 中实现QEMU 驱动具体的功能并在<code>src/qemu/qemu_capabilities.c</code> 中对内部提供一个接口了。这个接口要在<code>src/qemu/qemu_capabilities.h</code> 中声明以便被QEMU 驱动使用。</p>
<figure class="highlight patch"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">diff --git a/src/qemu/qemu_capabilities.c b/src/qemu/qemu_capabilities.c</div><div class="line">index 45ab5bbb6..8bf4efc7b 100644</div><div class="line"><span class="comment">--- a/src/qemu/qemu_capabilities.c</span></div><div class="line"><span class="comment">+++ b/src/qemu/qemu_capabilities.c</span></div><div class="line">@@ -5222,3 +5222,45 @@ virQEMUCapsFillDomainCaps(virCapsPtr caps,</div><div class="line">         return -1;</div><div class="line">     return 0;</div><div class="line"> &#125;</div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+char *</span></div><div class="line"><span class="addition">+virQEMUCapsGetMagicFileContent(virCapsPtr caps ATTRIBUTE_UNUSED)</span></div><div class="line"><span class="addition">+&#123;</span></div><div class="line"><span class="addition">+    FILE *fh = NULL;</span></div><div class="line"><span class="addition">+    char *content = NULL;</span></div><div class="line"><span class="addition">+    char *ret = NULL;</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+    if (-1 == access(VIR_CONNECT_MAGIC_FILE_PATH, R_OK)) &#123;</span></div><div class="line"><span class="addition">+        return NULL;</span></div><div class="line"><span class="addition">+    &#125;</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+    if (!(fh = fopen(VIR_CONNECT_MAGIC_FILE_PATH, "r"))) &#123;</span></div><div class="line"><span class="addition">+        virReportSystemError(errno, _("failed to open file %s"),</span></div><div class="line"><span class="addition">+                             VIR_CONNECT_MAGIC_FILE_PATH);</span></div><div class="line"><span class="addition">+        return NULL;</span></div><div class="line"><span class="addition">+    &#125;</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+    if (VIR_ALLOC_N(content, VIR_CONNECT_MAGIC_FILE_CONTENT_LEN) &lt; 0) &#123;</span></div><div class="line"><span class="addition">+        ret = NULL;</span></div><div class="line"><span class="addition">+        goto cleanup;</span></div><div class="line"><span class="addition">+    &#125;</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+    memset (content, 0, VIR_CONNECT_MAGIC_FILE_CONTENT_LEN);</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+    if (!fgets(content, VIR_CONNECT_MAGIC_FILE_CONTENT_LEN, fh)) &#123;</span></div><div class="line"><span class="addition">+        virReportSystemError(errno, _("failed to read file %s"),</span></div><div class="line"><span class="addition">+                             VIR_CONNECT_MAGIC_FILE_PATH);</span></div><div class="line"><span class="addition">+        ret = NULL;</span></div><div class="line"><span class="addition">+        goto cleanup;</span></div><div class="line"><span class="addition">+    &#125;</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+    ret = content;</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+cleanup:</span></div><div class="line"><span class="addition">+    if (VIR_FCLOSE (fh) &lt; 0) &#123;</span></div><div class="line"><span class="addition">+        virReportSystemError(errno, _("failed to close file %d"), fileno (fh));</span></div><div class="line"><span class="addition">+    &#125;</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+    return ret;</span></div><div class="line"><span class="addition">+&#125;</span></div><div class="line">diff --git a/src/qemu/qemu_capabilities.h b/src/qemu/qemu_capabilities.h</div><div class="line">index ee4bbb329..4efd31e38 100644</div><div class="line"><span class="comment">--- a/src/qemu/qemu_capabilities.h</span></div><div class="line"><span class="comment">+++ b/src/qemu/qemu_capabilities.h</span></div><div class="line">@@ -525,4 +525,6 @@ int virQEMUCapsFillDomainCaps(virCapsPtr caps,</div><div class="line">                               virFirmwarePtr *firmwares,</div><div class="line">                               size_t nfirmwares);</div><div class="line"></div><div class="line"><span class="addition">+char *virQEMUCapsGetMagicFileContent(virCapsPtr caps);</span></div><div class="line"><span class="addition">+</span></div><div class="line"> #endif /* __QEMU_CAPABILITIES_H__*/</div></pre></td></tr></table></figure>
<p>这一部分结束后，直接实现功能的那一部分代码就已经完成了。</p>
<blockquote>
<p>现在调用链如下。</p>
<p>??? -&gt; <code>virConnectGetMagicFileContent</code>@LibVirt -&gt; <code>remoteConnectGetMagicFileContent</code>@remote -&gt; <code>qemuConnectGetMagicFileContent</code>@QEMU -&gt; <code>virQEMUCapsGetMagicFileContent</code>@QEMU</p>
</blockquote>
<h2 id="实现remote-驱动"><a href="#实现remote-驱动" class="headerlink" title="实现remote 驱动"></a>实现remote 驱动</h2><p>remote 协议由两台主机的LibVirt 交换信息所用，当LibVirt 连接到远程主机时（例如<code>virsh -c</code>），之前实现的公共API 中通过<code>conn-&gt;driver</code> 结构体变量调用的函数会由remote 驱动处理。本机的LibVirt 将会请求远程的LibVirt 执行公共API，进而执行远程主机具体的hypervisor 驱动，然后得到返回的数据。既然有信息交换，就必须定义协议。</p>
<p>协议的定义涉及到几个文件，其中需要手动修改的文件如下。</p>
<ol>
<li><code>src/remote/remote_driver.c</code>: 定义了客户端的remote 驱动处理函数。</li>
<li><code>src/remote/remote_protocol.x</code>: 协议格式。</li>
<li><code>src/remote_protocol-structs</code>: 协议格式。</li>
</ol>
<p>以上文件的前两个会被脚本<code>src/rpc/gendispatch.pl</code> 处理，进而生成以下四个文件。</p>
<ol>
<li><code>src/remote/remote_client_bodies.h</code>: 实现了remote 驱动客户端API。</li>
<li><code>daemon/remote_dispatch.h</code>: 实现了remote 驱动服务器端API。</li>
<li><code>src/access/viraccessapicheck.h</code>：声明了API 权限检查函数。</li>
<li><code>src/access/viraccessapicheck.c</code>：实现了API 权限检查函数。</li>
</ol>
<p>remote 驱动的函数体就实现在前两个头文件中，客户端的API 经过一系列API 调用，最终由函数<code>virNetClientProgramCall</code> 完成信息的交互，其中两个类型为<code>void *</code> 的参数保存了传递给服务器端remote 驱动的参数和服务器端返回的数据，这两个参数的类型由两个类型为<code>xdrproc_t</code> 的参数确定。</p>
<h3 id="实现客户端驱动"><a href="#实现客户端驱动" class="headerlink" title="实现客户端驱动"></a>实现客户端驱动</h3><p>在<code>src/remote/remote_driver.c</code> 中，我们只要简单的修改结构体变量<code>hypervisor_driver</code> 即可。</p>
<figure class="highlight patch"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">diff --git a/src/remote/remote_driver.c b/src/remote/remote_driver.c</div><div class="line">index 888052045..65afda6fb 100644</div><div class="line"><span class="comment">--- a/src/remote/remote_driver.c</span></div><div class="line"><span class="comment">+++ b/src/remote/remote_driver.c</span></div><div class="line">@@ -8205,6 +8205,7 @@ static virHypervisorDriver hypervisor_driver = &#123;</div><div class="line">     .domainMigrateStartPostCopy = remoteDomainMigrateStartPostCopy, /* 1.3.3 */</div><div class="line">     .domainGetGuestVcpus = remoteDomainGetGuestVcpus, /* 2.0.0 */</div><div class="line">     .domainSetGuestVcpus = remoteDomainSetGuestVcpus, /* 2.0.0 */</div><div class="line"><span class="addition">+    .connectGetMagicFileContent = remoteConnectGetMagicFileContent, /* 2.5.0 */</span></div><div class="line"> &#125;;</div><div class="line"></div><div class="line"> static virNetworkDriver network_driver = &#123;</div></pre></td></tr></table></figure>
<p>这里我们只是简单的为结构体变量增加了一个元素，这个元素的类型为函数指针<code>virDrvConnectGetMagicFileContent</code>，在定义内部API 时添加到了类型<code>struct _virHypervisorDriver</code> 的声明当中，值为<code>remoteConnectGetMagicFileContent</code>，这是<code>src/rpc/gendispatch.pl</code> 输出到<code>src/remote/remote_client_bodies.h</code> 中的函数名。</p>
<h3 id="定义协议格式"><a href="#定义协议格式" class="headerlink" title="定义协议格式"></a>定义协议格式</h3><p>根据之前说的数据交换方式，我们这里需要定义具体的类型给函数<code>virNetClientProgramCall</code> 的两个<code>xdrproc_t</code> 的参数使用。这里针对每个API 需要定义两个结构体，其名字可以参考其他的结构体和对应的API。后跟<code>_args</code> 的结构体为API 的参数，<code>_ret</code> 的则为返回值，<code>virNetClientProgramCall</code> 会将两个<code>void *</code> 类型的参数分别解释为两个结构体类型，并通过这两个参数完成和远程主机的交互。如果remote 驱动不需要参数，那么可以省略以<code>_args</code> 结尾的结构体。</p>
<p>假设这里我们定义了如下两个结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> remote_connect_abadcafe_args &#123;</div><div class="line">    remote_nonnull_string str;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> remote_connect_abadcafe_ret &#123;</div><div class="line">    <span class="keyword">int</span> need_results;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>那么它会在文件<code>src/remote/remote_client_bodies.h</code> 中生成类似下面的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></div><div class="line"><span class="title">remoteConnectAbadcafe</span><span class="params">(virConnectPtr conn, <span class="keyword">const</span> <span class="keyword">char</span> *str)</span> &#123; &#125;</div></pre></td></tr></table></figure>
<p>除此之外，还需要阅读文件<code>src/remote/remote_protocol.x</code> 第403-426 行的注释，特别是<code>insert@offset</code> 相关的说明，你可能会需要它们的。</p>
<p>文件<code>src/remote/remote_protocol.x</code> 的Patch 如下。</p>
<figure class="highlight patch"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">diff --git a/src/remote/remote_protocol.x b/src/remote/remote_protocol.x</div><div class="line">index e8382dc51..e5c56220d 100644</div><div class="line"><span class="comment">--- a/src/remote/remote_protocol.x</span></div><div class="line"><span class="comment">+++ b/src/remote/remote_protocol.x</span></div><div class="line">@@ -3341,6 +3341,9 @@ struct remote_domain_set_guest_vcpus_args &#123;</div><div class="line">     unsigned int flags;</div><div class="line"> &#125;;</div><div class="line"></div><div class="line"><span class="addition">+struct remote_connect_get_magic_file_content_ret &#123;</span></div><div class="line"><span class="addition">+    remote_nonnull_string content;</span></div><div class="line"><span class="addition">+&#125;;</span></div><div class="line"></div><div class="line"> /*----- Protocol. -----*/</div><div class="line"></div><div class="line">@@ -5934,5 +5937,12 @@ enum remote_procedure &#123;</div><div class="line">      * @generate: both</div><div class="line">      * @acl: none</div><div class="line">      */</div><div class="line"><span class="deletion">-    REMOTE_PROC_NODE_DEVICE_EVENT_UPDATE = 377</span></div><div class="line"><span class="addition">+    REMOTE_PROC_NODE_DEVICE_EVENT_UPDATE = 377,</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+    /**</span></div><div class="line"><span class="addition">+     * @generate: both</span></div><div class="line"><span class="addition">+     * @priority: high</span></div><div class="line"><span class="addition">+     * @acl: connect:read</span></div><div class="line"><span class="addition">+     */</span></div><div class="line"><span class="addition">+    REMOTE_PROC_CONNECT_GET_MAGIC_FILE_CONTENT = 378</span></div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<p>除了之前提到的结构体之外，我们还修改了枚举类型<code>remote_procedure</code>，关于这个类型的具体修改请参阅文件<code>src/remote/remote_protocol.x</code> 第3355-3398 行的详尽注释。</p>
<p>根据设置的参数和返回值结构体，在编译过程中，以下函数会生成。</p>
<ol>
<li><code>remoteConnectGetMagicFileContent</code>: remote 驱动客户端API，位于文件<code>src/remote/remote_client_bodies.h</code>。</li>
<li><code>spatchConnectGetMagicFileContent</code>: remote 驱动服务器端API，位于文件<code>daemon/remote_dispatch.h</code>。</li>
<li><code>virConnectGetMagicFileContentEnsureACL</code>：API 权限检查函数，位于文件<code>src/access/viraccessapicheck.c</code>（所以请仔细阅读关于<code>@acl</code> 的注释）。</li>
</ol>
<h3 id="更新remote-protocol-structs"><a href="#更新remote-protocol-structs" class="headerlink" title="更新remote_protocol-structs"></a>更新remote_protocol-structs</h3><p>在上面两个步骤做完之后，只需要更新一下<code>src/remote_protocol-structs</code> 即可。</p>
<figure class="highlight patch"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">diff --git a/src/remote_protocol-structs b/src/remote_protocol-structs</div><div class="line">index b71accc07..383a5361d 100644</div><div class="line"><span class="comment">--- a/src/remote_protocol-structs</span></div><div class="line"><span class="comment">+++ b/src/remote_protocol-structs</span></div><div class="line">@@ -2791,6 +2791,9 @@ struct remote_domain_set_guest_vcpus_args &#123;</div><div class="line">         int                        state;</div><div class="line">         u_int                      flags;</div><div class="line"> &#125;;</div><div class="line"><span class="addition">+struct remote_connect_get_magic_file_content_ret &#123;</span></div><div class="line"><span class="addition">+    remote_nonnull_string content;</span></div><div class="line"><span class="addition">+&#125;;</span></div><div class="line"> enum remote_procedure &#123;</div><div class="line">         REMOTE_PROC_CONNECT_OPEN = 1,</div><div class="line">         REMOTE_PROC_CONNECT_CLOSE = 2,</div><div class="line">@@ -3169,4 +3172,5 @@ enum remote_procedure &#123;</div><div class="line">         REMOTE_PROC_CONNECT_NODE_DEVICE_EVENT_DEREGISTER_ANY = 375,</div><div class="line">         REMOTE_PROC_NODE_DEVICE_EVENT_LIFECYCLE = 376,</div><div class="line">         REMOTE_PROC_NODE_DEVICE_EVENT_UPDATE = 377,</div><div class="line"><span class="addition">+        REMOTE_PROC_CONNECT_GET_MAGIC_FILE_CONTENT = 378</span></div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>现在调用链如下，因为现在增加了客户端和服务端的概念，所以通过在其后增加<code>@client</code> 或<code>@server</code> 区分。</p>
<p>??? -&gt; <code>virConnectGetMagicFileContent</code>@LibVirt@client -&gt; <code>remoteConnectGetMagicFileContent</code>@remote@client -&gt; <code>remoteDispatchConnectGetMagicFileContent</code>@remote@server -&gt; <code>virConnectGetMagicFileContent</code>@LibVirt@server -&gt; <code>qemuConnectGetMagicFileContent</code>@QEMU@server -&gt; <code>virQEMUCapsGetMagicFileContent</code>@QEMU@server</p>
</blockquote>
<h2 id="在virsh-中实现功能"><a href="#在virsh-中实现功能" class="headerlink" title="在virsh 中实现功能"></a>在virsh 中实现功能</h2><p>最后要做的就是在<code>virsh</code> 中添加一个命令行选项，完成之前实现的公共API 的调用，并且将API 返回的数据打印到屏幕上。</p>
<p>你需要修改<code>tools/virsh-*.c</code> 以接受新的命令行选项。对于一个新的参数，你需要在<code>hostAndHypervisorCmds</code> 结构体数组中添加新的元素，并根据这个结构体中元素的值来定义两个结构体数组，类型分别为<code>vshCmdInfo</code> 和<code>vshCmdOptDef</code>，分别用来确定新选项的说明和参数。</p>
<p>针对我们实现公共API 的位置，这里我们在<code>tools/virsh-host.c</code> 中添加新的选项。</p>
<figure class="highlight patch"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">diff --git a/tools/virsh-host.c b/tools/virsh-host.c</div><div class="line">index 2fd368662..ed0c39f5d 100644</div><div class="line"><span class="comment">--- a/tools/virsh-host.c</span></div><div class="line"><span class="comment">+++ b/tools/virsh-host.c</span></div><div class="line">@@ -1379,6 +1379,41 @@ cmdNodeMemoryTune(vshControl *ctl, const vshCmd *cmd)</div><div class="line">     goto cleanup;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="addition">+/*</span></div><div class="line"><span class="addition">+ * "get-magic" command</span></div><div class="line"><span class="addition">+ */</span></div><div class="line"><span class="addition">+static const vshCmdInfo info_getmagic[] = &#123;</span></div><div class="line"><span class="addition">+    &#123;.name = "help",</span></div><div class="line"><span class="addition">+     .data = N_("Get magic file's content")</span></div><div class="line"><span class="addition">+    &#125;,</span></div><div class="line"><span class="addition">+    &#123;.name = "desc",</span></div><div class="line"><span class="addition">+     .data = N_("Get magic file's content")</span></div><div class="line"><span class="addition">+    &#125;,</span></div><div class="line"><span class="addition">+    &#123;.name = NULL&#125;</span></div><div class="line"><span class="addition">+&#125;;</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+static const vshCmdOptDef opts_getmagic[] = &#123;</span></div><div class="line"><span class="addition">+    &#123;.name = NULL&#125;</span></div><div class="line"><span class="addition">+&#125;;</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+static bool</span></div><div class="line"><span class="addition">+cmdGetMagic(vshControl *ctl, const vshCmd *cmd ATTRIBUTE_UNUSED)</span></div><div class="line"><span class="addition">+&#123;</span></div><div class="line"><span class="addition">+    char *ret = NULL;</span></div><div class="line"><span class="addition">+    virshControlPtr priv = ctl-&gt;privData;</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+    ret = virConnectGetMagicFileContent(priv-&gt;conn);</span></div><div class="line"><span class="addition">+    if (!ret) &#123;</span></div><div class="line"><span class="addition">+        vshError(ctl, "%s", _("failed to get magic file's content"));</span></div><div class="line"><span class="addition">+        return false;</span></div><div class="line"><span class="addition">+    &#125;</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+    vshPrint(ctl, _("Magic file's content: %s"), ret);</span></div><div class="line"><span class="addition">+    VIR_FREE (ret);</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+    return true;</span></div><div class="line"><span class="addition">+&#125;</span></div><div class="line"><span class="addition">+</span></div><div class="line"> const vshCmdDef hostAndHypervisorCmds[] = &#123;</div><div class="line">     &#123;.name = "allocpages",</div><div class="line">      .handler = cmdAllocpages,</div><div class="line">@@ -1482,5 +1517,11 @@ const vshCmdDef hostAndHypervisorCmds[] = &#123;</div><div class="line">      .info = info_version,</div><div class="line">      .flags = 0</div><div class="line">     &#125;,</div><div class="line"><span class="addition">+    &#123;.name = "get-magic",</span></div><div class="line"><span class="addition">+     .handler = cmdGetMagic,</span></div><div class="line"><span class="addition">+     .opts = opts_getmagic,</span></div><div class="line"><span class="addition">+     .info = info_getmagic,</span></div><div class="line"><span class="addition">+     .flags = 0</span></div><div class="line"><span class="addition">+    &#125;,</span></div><div class="line">     &#123;.name = NULL&#125;</div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<p>最后修改一下<code>tools/virsh.pod</code>，这个文件将会被<code>pod2man</code> 处理成<code>virsh(1)</code> 的手册。POD 是源于<a href="https://www.perl.org" target="_blank" rel="external">Perl</a> 的简单易用的标记语言，可以通过<code>perldoc perlpod</code> 来查看其语法的更多说明。</p>
<figure class="highlight patch"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">diff --git a/tools/virsh.pod b/tools/virsh.pod</div><div class="line">index 247d2357b..2d19df86b 100644</div><div class="line"><span class="comment">--- a/tools/virsh.pod</span></div><div class="line"><span class="comment">+++ b/tools/virsh.pod</span></div><div class="line">@@ -611,6 +611,18 @@ specified, then the output will be single-quoted where needed, so that</div><div class="line"> it is suitable for reuse in a shell context.  If I&lt;--xml&gt; is</div><div class="line"> specified, then the output will be escaped for use in XML.</div><div class="line"></div><div class="line"><span class="addition">+=item B&lt;get-magic&gt;</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+Get magic file's content.</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+=item B&lt;set-magic&gt; [I&lt;content&gt;]</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+Set magic file's content.</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+=item B&lt;magic-status&gt;</span></div><div class="line"><span class="addition">+</span></div><div class="line"><span class="addition">+Show if magic file can be read.</span></div><div class="line"><span class="addition">+</span></div><div class="line"> =back</div><div class="line"></div><div class="line"> =head1 DOMAIN COMMANDS</div></pre></td></tr></table></figure>
<p>到现在已经完成了包括文档在内的所有工作，如果你要为LibVirt 添加一个新的功能，所需要做的大约就是这么多。</p>
<blockquote>
<p>最终的调用链如下。</p>
<p><code>cmdGetMagic</code>@virsh@client -&gt; <code>virConnectGetMagicFileContent</code>@LibVirt@client -&gt; <code>remoteConnectGetMagicFileContent</code>@remote@client -&gt; <code>remoteDispatchConnectGetMagicFileContent</code>@remote@server -&gt; <code>virConnectGetMagicFileContent</code>@LibVirt@server -&gt; <code>qemuConnectGetMagicFileContent</code>@QEMU@server -&gt; <code>virQEMUCapsGetMagicFileContent</code>@QEMU@server</p>
</blockquote>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h2><p>现在我们已经完成了最后一步，可以最后编译一次源码并测试一下功能。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">make -j8</div><div class="line">make <span class="built_in">test</span> -j8</div></pre></td></tr></table></figure>
<p>如果编译无误的话，在一个新的终端里运行<code>daemon/libvirtd</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo ./run ./daemon/libvirtd</div></pre></td></tr></table></figure>
<p>然后看一看新添加的API 是否工作正常。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">'Hello World!'</span> | sudo tee /var/run/libvirt/magic_file</div><div class="line">sudo ./run ./tools/virsh -c qemu:///system get-magic</div></pre></td></tr></table></figure>
<p>如果一切顺利，现在你已经在终端里看到了刚才写入到文件的<code>Hello World!</code> :)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GTK事件及信号机制]]></title>
      <url>https://arondight.github.io/2016/07/19/GTK%E4%BA%8B%E4%BB%B6%E5%8F%8A%E4%BF%A1%E5%8F%B7%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>最近在给公司重写一版用Qt3 写的软件，界面比较老，功能也年久失修，商量了一下决定用GTK 重写界面和功能。之前接触的都是Qt，对GTK 了解不多。个人觉得跟Qt 的信号-槽机制相比，GTK 的的信号回调机制稍显不同。然后这篇文章就是自己理解的GTK 信号回调机制。</p>
<h2 id="事件和信号"><a href="#事件和信号" class="headerlink" title="事件和信号"></a>事件和信号</h2><p>GTK 是一个基于<strong>事件</strong>驱动的框架，就是说GTK 程序会一直循环在<code>gtk_main</code> 函数中，直至一个事件发生，然后跳转到对应的事件处理函数中，执行完毕后再次回到<code>gtk_main</code> 的循环。这听起来很符合逻辑，但是GTK 中除了事件外，还有一个概念是<strong>信号</strong>，特别是当你写几个GTK 程序后就会发现你处理的几乎都是信号。</p>
<p>典型的例如。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g_signal_connect (G_OBJECT (mainWindow), <span class="string">"delete_event"</span>, G_CALLBACK (gtk_main_quit), <span class="literal">NULL</span>);</div></pre></td></tr></table></figure>
<p>那么<code>&quot;delete_event&quot;</code> 到底是事件还是信号——它被用于<code>g_signal_connect</code> 中，但是名字带有<code>event</code> 字样。</p>
<a id="more"></a>
<p>在GTK 中，事件是X11 中发生的，GTK 通过GDK 将X11 中的<code>XEvent</code> 转化为<code>GdkEvent</code>，其类型<code>GdkEventType</code> 定义在头文件<code>gdk/gdkevents.h</code> 中。</p>
<blockquote>
<p>GDK 是Xlib 的一个封装。</p>
</blockquote>
<p>而信号与事件不同，是GTK 本身的概念。在GTK 中，一个事件发生之后，会通过函数<code>gtk_widget_event</code> 将事件转化为信号，并通过函数<code>g_signal_emit</code> 将信号发射出去，如果有回调和该信号绑定，那么这个回调<strong>有可能</strong>被执行。</p>
<p>举例来说，当<code>GtkButton</code> 上发生了鼠标点击的动作时，默认地事件和信号的顺序如下。</p>
<ol>
<li><code>GDK_BUTTON_PRESS</code> 事件产生 -&gt; 调用GDK 中针对该事件的回调</li>
<li><code>&quot;button_press_event&quot;</code> 信号发射 -&gt; 调用GTK 中针对该信号的回调</li>
<li><code>&quot;clicked&quot;</code> 信号发射 -&gt; 调用GTK 中针对该信号的回调</li>
</ol>
<p>那么<code>&quot;delete_event&quot;</code> 到底是事件还是信号？它是一个信号，但是只有在事件<code>GDK_DELETE</code> 发生后才会被发射出去，所以它也代表一个事件。</p>
<p>这也是GTK 一个稍微有点混乱的地方——<strong>事件的发生是通过信号的发射反应的</strong>。所以你如果想在GTK 中处理事件，你需要处理信号。</p>
<h2 id="回调机制"><a href="#回调机制" class="headerlink" title="回调机制"></a>回调机制</h2><h3 id="回调的绑定"><a href="#回调的绑定" class="headerlink" title="回调的绑定"></a>回调的绑定</h3><p>和Qt 的信号-槽机制不同，GTK 中采用回调机制来处理信号。GTK 中为信号绑定回调的方式都通过同一个函数<code>g_signal_connect_data</code> 完成，其原形定义在头文件<code>gobject/gsignal.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">gulong <span class="title">g_signal_connect_data</span> <span class="params">(gpointer instance, <span class="keyword">const</span> gchar *detailed_signal,</span></span></div><div class="line">                              GCallback c_handler, gpointer data,</div><div class="line">                              GClosureNotify destroy_data, GConnectFlags connect_flags);</div></pre></td></tr></table></figure>
<blockquote>
<p>因为信号处理在Glib 而非GTK 中，所以函数名以<code>g_</code> 而非<code>gtk_</code> 开头。</p>
</blockquote>
<p>但是更加常用的是在其上封装的三个宏，与<code>g_signal_connect_data</code> 定义在同一个头文件中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> g_signal_connect(instance, detailed_signal, c_handler, data) \</span></div><div class="line">  g_signal_connect_data ((instance), (detailed_signal), (c_handler), (data), NULL, (GConnectFlags) 0)</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> g_signal_connect_after(instance, detailed_signal, c_handler, data) \</span></div><div class="line">  g_signal_connect_data ((instance), (detailed_signal), (c_handler), (data), NULL, G_CONNECT_AFTER)</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> g_signal_connect_swapped(instance, detailed_signal, c_handler, data) \</span></div><div class="line">  g_signal_connect_data ((instance), (detailed_signal), (c_handler), (data), NULL, G_CONNECT_SWAPPED)</div></pre></td></tr></table></figure>
<p>其中。</p>
<ul>
<li><code>g_signal_connect</code>： 为信号绑定一个回调函数，该回调将先于默认回调执行。</li>
<li><code>g_signal_connect_after</code>： 和<code>g_singal_connect</code> 类似，但是该回调将在默认回调之后执行。</li>
<li><code>g_signal_connect_swapped</code>：回调先于默认回调执行，但是回调的参数位置应该和前两个绑定函数的回调参数位置交换。</li>
</ul>
<p><code>g_signal_connect_swapped</code> 中<code>swapped</code> 的效果如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span> <span class="params">(GtkWidget *widget, gpointer data)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">handlerSwapped</span> <span class="params">(gpointer data, GtkWidget *widget)</span></span>;</div></pre></td></tr></table></figure>
<blockquote>
<p>个人觉得<code>g_signal_connect_swapped</code> 最好少用，它只会把水搅浑。</p>
</blockquote>
<h3 id="回调的形式"><a href="#回调的形式" class="headerlink" title="回调的形式"></a>回调的形式</h3><p>在Gtk 中，回调的形式有两种，在反应事件的信号回调中，handler 需要额外增加一个<code>GdkEvent *</code> 参数，用来传入发生的事件。</p>
<p>这两种回调之间的区别如下（假设使用<code>g_signal_connect</code> 绑定）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">buttonClickedHandler</span> <span class="params">(GtkWidget *button, gpointer data)</span></span>;</div><div class="line"><span class="function">gboolean <span class="title">keyPressEventHandler</span> <span class="params">(GtkWidget *button, GdkEvent *event, gpointer data)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="回调的返回值"><a href="#回调的返回值" class="headerlink" title="回调的返回值"></a>回调的返回值</h3><p>除了增加了<code>GdkEvent *</code> 作为参数外，处理事件的回调函数多了一个<code>gboolean</code> 类型的返回值，这个返回值用于控制该事件处理过程是否继续。</p>
<p>返回值的情况如下。</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TRUE</code></td>
<td>该事件已经处理完毕，不再继续调用其他和该事件绑定的回调</td>
</tr>
<tr>
<td><code>FALSE</code></td>
<td>需要继续执行其他与该事件绑定的回调函数</td>
</tr>
</tbody>
</table>
<h3 id="回调的调用顺序"><a href="#回调的调用顺序" class="headerlink" title="回调的调用顺序"></a>回调的调用顺序</h3><p>因为GTK 先捕获事件再转化为信号，所以直接反应事件的信号在其他信号之前被发射，所以同一个<code>GtkWidget</code> 上处理事件的回调总在其他信号回调之前被执行。</p>
<p>所以“回调的形式”一节的代码片中，假设<code>buttonClickedHandler</code> 和<code>keyPressEventHandler</code>  分别被绑定到一个<code>GtkButton</code> 的<code>&quot;event&quot;</code> 和<code>&quot;clicked&quot;</code> 信号上，如果<code>keyPressEventHandler</code> 返回<code>TRUE</code>，那么<code>buttonClickedHandler</code> 将不会被调用。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[为美好的世界献上祝福]]></title>
      <url>https://arondight.github.io/2016/05/03/%E4%B8%BA%E7%BE%8E%E5%A5%BD%E7%9A%84%E4%B8%96%E7%95%8C%E7%8C%AE%E4%B8%8A%E7%A5%9D%E7%A6%8F/</url>
      <content type="html"><![CDATA[<h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>说一下最近发生的两件事吧。</p>
<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>第一件事是在Github 上找到了自己三年前用的一些配置文件，于是晚上本地拉了一个空分支fetch 下来后push 了上去。因为整套配置文件都是用软连接分发的，而目录架构又三年多没有变过，所以当想用Vim 打开里面的配置看看当时写成什么样子的时候，却看到了一个很陌生的界面。因为仓库检出到了三年前的分支，所以我看到了三年前自己使用的Vim。</p>
<p>三年前我用着这个配置写过什么东西，最后那些事情也构成了现在的我。</p>
<a id="more"></a>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>第二件事是感觉越来越看不清未来的大致轮廓了，将来会做什么行业，会在哪个城市，一切都变得模糊了起来。很多周围的事物，包括以前认为理所当然的事情都变得不确定。“自己以后肯定会继续写程序吧”，“肯定会选择留在北京吧”，“肯定会在技术上有所发展吧”，然而这些“理所当然”的事情自己越发都觉得难以相信。</p>
<p>较之于爱好和方向，最重要的问题已经变成了如何更好地生活，其余的只是生活的手段，包括曾经自己坚持的东西。</p>
<h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>说一下这个行业吧，不只是程序员这一行，而是IT 这个行业，例如程序员、运维、测试之类的。</p>
<h3 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h3><p>大学里我对IT 的印象，编程几乎占了所有的比重。虽然和有的人说大学想学医却最终学了计算机，其实一半是撒谎，能够写程序也是高中时期我的梦想之一。所以从某些意义上来说，我也算选对了一个大学。所以从这个意义上，我也理所当然的毕业后成了一个程序员。虽然毕业之前很长时间都在踹踹不安，是不是应该考研，万一毕业后生活在社会最底层怎么办，以后应该向哪个领域发展……然而毕业后就发现曾经的不安并没有什么实际的意义，只有去工作才有工资，不管方向是不是很合口，你总得找一份。</p>
<p>第一家公司是一个做手机操作系统的公司，说实话并没写多少代码，基本都是二次开发，晚上经常八点才下班。现在的公司是做电脑操作系统的，编程的工作也不是很多，较之深度反而更加看重广度，好在一般不到六点就走人了。</p>
<p>然而无论如何，就结果而言我并没有像学生时代设想的那样成为一个100% 的程序员。</p>
<h3 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h3><p>也是一半撒谎，有时我会和别人说，有点后悔当初没有按照父母的安排在家乡进事业单位，否则就能过上安安稳稳的生活了，然而至少就现在而言我半点不曾后悔过。毕业后跟我去了同一个大学的两个兄弟留在了家乡，那里物价不贵，房租便宜，生活节奏很慢，晚上从七点开始，冬天六点多下班公交可能就停了。而我只身来了北京，一个晚上从九点开始的城市，物价很贵，房租普遍一个月一千五，房价高的几乎没有留下的可能性。</p>
<p>然而将安稳的生活和四倍的工资相比，我选择了后者，纵使代价是只能在一个远离家乡的地方漂着。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>好几次我妈给我打电话，说北京干够了就回家吧。挂上电话想想自己是不是真的能回去呢。IT 是一个很矛盾的行业，相对于传统行业好混一点，但是只有一线城市才有更多的机会。相较于在一个金钱贬值的地方多赚一点，似乎在三线城市有一份收入不高但安稳的工作也挺不错吧。然而无论混的好坏，很少见到一个做IT 的出来几年就回去的。如果真的回了家乡，那么敲键盘就很难赚到钱了，除了敲键盘，你还有什么吃饭的技能呢。</p>
<p>你只能在一个自我价值贬值的地方才能够提升自身的存在价值，我觉得对于不少人而言做IT 就是这么个东西，至少对于现在的我而言是这样的。</p>
<h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>说一些其他的事情吧。</p>
<h3 id="1-2"><a href="#1-2" class="headerlink" title="1"></a>1</h3><p>最近开始变得越来越懒了，下班回来以后在群里扯扯淡，打开哔哩哔哩追追番，然后发呆一会儿，就到了睡觉的时间。然而就在三四个月前的时候还经常晚上在电脑前敲代码很久，那个时期我真的会去认认真真的花上业余时间去学一些东西。当然现在也想学一些东西，例如Java，例如服务器端开发，例如NodeJS，有一段时间还曾经想学Common Lisp，然而这些东西我都没有认真的开始学过。有时候也在想，以后转行该怎么办，总得有一门拿得出手的手艺，所以总得有一个确定而且熟悉的方向。然而又转念一想，以后做什么还都是未知，也没有必要非得这么着急去学精一门技能吧。</p>
<p>我说不好这中间到底有什么改变了，然而相对于学习新的知识，能够生活的轻松一点成了我当下切实的愿望。</p>
<h3 id="2-2"><a href="#2-2" class="headerlink" title="2"></a>2</h3><p>最近看了两部很喜欢的动画，一部是《为美好的世界献上祝福！》，另一部是《Re：从零开始的异世界生活》，两部动画都是发生在异世界的故事。在异世界中认识各式各样的人，发生各种各样的故事，因为不同的目的开始旅行，因为不同的目的停止旅行。大概我很喜欢这种浪漫主义的故事，所以这样的作品对我有着致命的诱惑力。然而如果真的说给我一次去异世界的机会，恐怕我不会踏上那段旅程吧。相对于一段全新的生活，现代科技和文明带来的生活保障恐怕重要的多。然而我还是无法抵挡任何“异世界中踏上旅途”的设定，这种作品对我而言可以说是精神鸦片一样的存在。</p>
<p>大约我的生活太缺少这样非日常的元素了。</p>
<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>说一下现在吧。</p>
<p>在学生时代我大约会很喜欢说自己的现在，然而此时此刻却写不出什么东西——现在就那样，没啥好说的。然而无论自己觉得现在的生活是否有意义，我所做的琐事也会一点点构建自身，像开头说的那样，三年后这些琐事也会构成我的一部分吧。</p>
<p>说来也巧，也正是三年前我开始尝试着去看动漫，此后一发不可收拾。当时很喜欢的一部作品是奈绪蘑菇的《空之境界》，这部作品本篇一共三本小说，后来蘑菇又写了《空之境界 未来福音》作为故事的补完。《未来福音》的画廊中讲了式和干也在《矛盾螺旋》之后的新年里去神社做参拜的故事，在矛盾螺旋事件结束后，式和干也在新年参拜中各自许下自己的新年愿望。当面对式“肯定又是类似世界和平之类”的玩笑时，干也让人很舒服的笑着说“嘛，差不多吧”，然后一句画外音让我至今难忘。</p>
<blockquote>
<p>惟愿你与围绕你的这个世界，未来也能一直幸福下去。</p>
<p>祈愿中满溢着来自未来的福音。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用GPG签名Git提交和标签]]></title>
      <url>https://arondight.github.io/2016/04/17/%E4%BD%BF%E7%94%A8GPG%E7%AD%BE%E5%90%8DGit%E6%8F%90%E4%BA%A4%E5%92%8C%E6%A0%87%E7%AD%BE/</url>
      <content type="html"><![CDATA[<h2 id="Pretty-Good-Privacy"><a href="#Pretty-Good-Privacy" class="headerlink" title="Pretty Good Privacy"></a>Pretty Good Privacy</h2><h3 id="GPG-是什么"><a href="#GPG-是什么" class="headerlink" title="GPG 是什么"></a>GPG 是什么</h3><p>提GPG 之前需要提一个软件叫PGP。PGP 是“Pretty Good Privacy” 的缩写，中文直译为“完美隐私”，名字言简意赅，上来就把软件的用途拍用户脸上。然而PGP 不是自由软件，所以自由软件基金会决定开发一个替代PGP 的自由软件，于是有了GPG（GnuPG）。</p>
<p>GPG 可以提供对信息、文件的签名和验证，或者是加密和解密，主要用于不安全网络上的信息传输。为此GPG 需要一个密钥环，GPG 使用私钥和公钥分别完成签名和加密，对应地验证和解密由公钥和私钥完成。</p>
<a id="more"></a>
<h3 id="主钥、从钥、公钥、私钥"><a href="#主钥、从钥、公钥、私钥" class="headerlink" title="主钥、从钥、公钥、私钥"></a>主钥、从钥、公钥、私钥</h3><p>然而GPG 密钥环并不只有一对公钥和私钥，如果称公钥和其对应的私钥为一个密钥对的话，那么一个GPG 密钥环可以拥有很多个密钥对，每一个密钥对都由一个钥匙号（key ID）标识，被称为钥匙。其中有一个钥匙拥有签名其他钥匙的功能（可以在密钥环中创建钥匙），这个钥匙被称为主钥，其他的钥匙则被称为从钥。</p>
<p>下面列出了我在使用的一个密钥环，首先是公钥。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ gpg --list-keys</div><div class="line"><span class="section">/home/&lt;user&gt;/.gnupg/pubring.kbx</span></div><div class="line">---------------------------------</div><div class="line">pub   rsa4096/B66CC194 2016-04-15 [SC]</div><div class="line">uid         [ 绝对 ] Arondight &lt;shell<span class="emphasis">_way@foxmail.com&gt;</span></div><div class="line">sub   rsa4096/F96E3CB7 2016-04-15 [E]</div></pre></td></tr></table></figure>
<p>然后是私钥。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ gpg --list-secret-keys</div><div class="line"><span class="section">/home/&lt;user&gt;/.gnupg/pubring.kbx</span></div><div class="line">---------------------------------</div><div class="line">sec   rsa4096/B66CC194 2016-04-15 [SC]</div><div class="line">uid         [ 绝对 ] Arondight &lt;shell<span class="emphasis">_way@foxmail.com&gt;</span></div><div class="line">ssb   rsa4096/F96E3CB7 2016-04-15 [E]</div></pre></td></tr></table></figure>
<p>GPG 列出的每个密钥环第一行一定是主钥，其余的则为从钥，可以看到上面的密钥环中只有一个主钥和一个从钥。每个密钥后面有许多信息描述它的属性，例如<code>sec   rsa4096/B66CC194 2016-04-15 [SC]</code> 代表这是一个主钥的私钥，加密算法为rsa，长度4096 位，主钥的钥匙号为<code>B66CC194</code>，创建于2016 年4 月15 日，功能为<code>SC</code>。</p>
<p>不难看出一个GPG 密钥环一共有四种类型的密钥，如果按照上面指令的样例输出来看的话则如下表。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>代表</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>sec</td>
<td>SECret key</td>
<td>主钥的私钥</td>
</tr>
<tr>
<td>pub</td>
<td>PUBlic key</td>
<td>主钥的公钥</td>
</tr>
<tr>
<td>ssb</td>
<td>Secret SuBkey</td>
<td>从钥的私钥</td>
</tr>
<tr>
<td>sub</td>
<td>public SUBkey</td>
<td>从钥的公钥</td>
</tr>
</tbody>
</table>
<p>至于这些钥匙的作用可以查看它们的功能，常用的功能有三种。</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>代表</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>S</td>
<td>Signing</td>
<td>签名和验证信息</td>
</tr>
<tr>
<td>E</td>
<td>Encryption</td>
<td>加密和解密信息</td>
</tr>
<tr>
<td>C</td>
<td>Certification</td>
<td>签名和验证钥匙</td>
</tr>
</tbody>
</table>
<p>注意功能是针对一个钥匙而言的，由其中的公钥和私钥共同完成。其中加密和解密分别由钥匙的公钥和私钥完成，签名和验证则分别由私钥和公钥完成。一般地，GPG 密钥环中钥匙的公钥需要公布到网络上，也就意味着：</p>
<ol>
<li>所有人都能用你公布的公钥加密信息，加密后的信息只有持有私钥的你才能够解密。</li>
<li>你可以使用自己持有的私钥签名信息，所有人都能够用你公布的公钥验证签名的合法性。</li>
</ol>
<p>默认地，GPG 生成的密钥环，主钥用于签名和验证，从钥用于加密和解密。</p>
<h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><p>首先需要生成一个GPG 密钥环，GPG 在生成密钥的时候会使用一个根据你的操作生成的随机数，所以你可以在GPG 生成密钥的时候多做一些操作，例如点鼠标、敲键盘、复制文件等等。你可以利用<code>dd</code> 指令在生成密钥的期间做一些读写操作以让随机数字发生器获得足够的熵数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo dd <span class="keyword">if</span>=<span class="regexp">/dev/</span>random <span class="keyword">of</span>=<span class="regexp">/dev/</span><span class="literal">null</span> bs=<span class="number">4</span>M</div></pre></td></tr></table></figure>
<p>然后可以生成GPG 密钥环，推荐使用<code>--full-gen-key</code> 选项来启用所有的功能。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gpg <span class="comment">--full-gen-key</span></div></pre></td></tr></table></figure>
<p>其中需要注意的事情有以下几项：</p>
<ol>
<li>密钥种类：形如<code>method1 and method2</code> 的选项是生成主钥和一个从钥，默认可以用于签名和加密，形如<code>method</code> 的选项只生成主钥，默认只能用于签名。</li>
<li>密钥长度：越长越安全，同时加密解密的时间花费越多，选择一个你认为合理的长度。</li>
<li>有效期限：你需要选择一个你认为合理的有效期限，钥匙到期后，签名将失效，GPG 服务器也会删除其公钥，所以一般来说你需要使用一个永不过期的钥匙。</li>
<li>钥匙密码：一定要为你的钥匙设置一个足够强壮的密码！</li>
</ol>
<h3 id="上传公钥到服务器"><a href="#上传公钥到服务器" class="headerlink" title="上传公钥到服务器"></a>上传公钥到服务器</h3><p>现在你可以将你的公钥上传到任意GPG 服务器上了，这可以方便他人导入公钥以验证你的签名。通过服务器的交换机制，全球所有的GPG 服务器都会得到你的公钥。你可以列出你现在所拥有的公钥。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ gpg --list-keys</div><div class="line"><span class="section">/home/&lt;user&gt;/.gnupg/pubring.kbx</span></div><div class="line">---------------------------------</div><div class="line">pub   rsa4096/B66CC194 2016-04-15 [SC]</div><div class="line">uid         [ 绝对 ] Arondight &lt;shell<span class="emphasis">_way@foxmail.com&gt;</span></div><div class="line">sub   rsa4096/F96E3CB7 2016-04-15 [E]</div></pre></td></tr></table></figure>
<p>可以看到两个公钥，分别属于主钥<code>B66CC194</code> 和从钥<code>F96E3CB7</code>。上传时指定主钥的钥匙号（key ID）即可，GPG 会将密钥环中的公钥上传到指定的服务器。</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gpg --keyserver <span class="built_in">keys</span>.gnupg.net --send-<span class="built_in">keys</span> &lt;<span class="built_in">key</span> ID&gt;</div></pre></td></tr></table></figure>
<h3 id="上传公钥到GitHub"><a href="#上传公钥到GitHub" class="headerlink" title="上传公钥到GitHub"></a>上传公钥到GitHub</h3><p>GitHub 刚刚发布了支持GPG 签名的消息，所以你可以选择使用GitHub 托管你的仓库。首先你需要以文本形式导出你主钥的公钥。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gpg -<span class="selector-tag">a</span> -o gnupg<span class="selector-class">.pub</span> --export &lt;key ID&gt;</div></pre></td></tr></table></figure>
<p>然后打开你的GitHub <a href="https://github.com/settings/keys" target="_blank" rel="external">密钥管理</a>界面，根据文件<code>gnupg.pub</code> 为你的GitHub 账户配置用于验证签名的公钥。</p>
<blockquote>
<p>注意：这一步不是必须的，你不一定要使用GitHub，或许你更喜欢使用其他的商业产品，或者自己搭建一个Git 服务器。Git 本身就是支持GPG 签名的，GitHub 对GPG 的支持仅是把验证结果在网页上显示出来（使用你上传的公钥）。</p>
</blockquote>
<h3 id="导出指纹"><a href="#导出指纹" class="headerlink" title="导出指纹"></a>导出指纹</h3><p>然而不幸的是，任何人都可以冒充你的名义上传公钥到GPG 服务器，所以对方搜到以你的名义发布的公钥，不一定真的是你发布的。为了避免这个问题，你需要公布主钥的指纹。GPG 导入公钥后需要手动设置信任度。这时候对方就可以通过对比计算得到的主钥指纹和你提供的主钥指纹，来确定导入的主钥的合法性。</p>
<p>你可以像下面一样导出指纹。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gpg --fingerprint &lt;key ID&gt; <span class="params">| perl -nE '$.-2 <span class="keyword">or</span> s/^\h+// <span class="keyword">and</span> print' |</span> tee fingerprint</div></pre></td></tr></table></figure>
<p>然后将<code>fingerprint</code> 文件提交到你的项目仓库中，或者公布在网络的其他位置。</p>
<blockquote>
<ol>
<li>你只需（只能）导出主钥的指纹，对方也只需要验证主钥的指纹，因为主钥的公钥可以验证从钥。</li>
<li>你可以通过<code>--export-ownertrust</code> 和<code>--import-ownertrust</code> 来直接导出和导入信任度，但是不推荐这样做。</li>
</ol>
</blockquote>
<h3 id="签名提交和标签"><a href="#签名提交和标签" class="headerlink" title="签名提交和标签"></a>签名提交和标签</h3><p>首先你需要为Git 设置一个用于签名的私钥，通常来说所有的个人项目都用一个私钥进行签名，所以建议设置为全局配置。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git config --global <span class="keyword">user</span>.signingkey <span class="variable">&lt;key ID&gt;</span></div></pre></td></tr></table></figure>
<p>然后就可以使用这个私钥来签名提交。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>git commit -S</div></pre></td></tr></table></figure>
<p>或者签名标签了。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="keyword">tag</span> <span class="title">-s</span> <span class="tag">&lt;tag&gt;</span></div></pre></td></tr></table></figure>
<p>如果你想全局默认使用GPG 签名提交，可以全局将<code>commit.gpgsign</code> 设置为<code>true</code>。</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git config --<span class="keyword">global</span> commit.gpgsign <span class="literal">true</span></div></pre></td></tr></table></figure>
<h3 id="关于私钥"><a href="#关于私钥" class="headerlink" title="关于私钥"></a>关于私钥</h3><p>任何情况向下都不要把私钥泄露给除了你之外的任何人。如果需要向对方发送加密信息，请让对方提供指纹，导入对方的公钥进行加密，而不要用自己的公钥加密后再把自己的私钥发送过去。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h3 id="获得公钥"><a href="#获得公钥" class="headerlink" title="获得公钥"></a>获得公钥</h3><p>你可以根据你得到的信息在任何GPG 服务器上查找对应的公钥，典型的例如查看指纹（后8 位数字为钥匙号），然后根据得到的钥匙号到服务器上查找钥匙。</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gpg --keyserver <span class="built_in">keys</span>.gnupg.net --search-<span class="built_in">keys</span> &lt;<span class="built_in">key</span> ID&gt;</div></pre></td></tr></table></figure>
<p>选择对应的编号，会自动下载并导入该公钥。你也可以根据用户名和邮箱进行查找。</p>
<h3 id="设置信任"><a href="#设置信任" class="headerlink" title="设置信任"></a>设置信任</h3><p>导入后的公钥需要设置信任度才能使用该公钥进行验证，你可以通过类似下面的指令编辑该公钥的信息。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gpg --<span class="keyword">edit</span>-<span class="built_in">key</span> &lt;<span class="built_in">key</span> ID&gt;</div></pre></td></tr></table></figure>
<p>你所看到的应该是一个文本交互界面，下面是一个样例。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">gpg (GnuPG) <span class="number">2.1</span>.<span class="number">11</span>; Copyright (C) <span class="number">2016</span> Free Software Foundation, Inc.</div><div class="line">This <span class="keyword">is</span> free software: you are free <span class="keyword">to</span> change <span class="keyword">and</span> redistribute <span class="literal">it</span>.</div><div class="line">There <span class="keyword">is</span> NO WARRANTY, <span class="keyword">to</span> the extent permitted <span class="keyword">by</span> law.</div><div class="line"></div><div class="line"></div><div class="line">pub  rsa4096/B66CC194</div><div class="line">     创建于：<span class="number">2016</span>-<span class="number">04</span>-<span class="number">15</span>  有效至：永不过期  可用于：SC</div><div class="line">     信任度：未知        有效性：未知</div><div class="line">sub  rsa4096/F96E3CB7</div><div class="line">     创建于：<span class="number">2016</span>-<span class="number">04</span>-<span class="number">15</span>  有效至：永不过期  可用于：E</div><div class="line">[ 未知 ] (<span class="number">1</span>). Arondight &lt;shell_way@foxmail.com&gt;</div><div class="line"></div><div class="line">gpg&gt;</div></pre></td></tr></table></figure>
<p>你可以键入<code>fpr</code> 来打印这个主钥的指纹，和你得到的主钥指纹进行对比，如果一致则键入<code>trust</code> 来设置主钥的信任度。如果主钥被设置为绝对可信的（ultimately），GPG 会根据主钥的公钥验证从钥的签名，最终完成信任建立。最后键入<code>quit</code> 退出。</p>
<h3 id="验证签名"><a href="#验证签名" class="headerlink" title="验证签名"></a>验证签名</h3><p>现在你可以用导入的公钥来验证你<code>git clone</code> 下来的仓库的提交和标签了，同样你需要首先告诉Git 应该使用哪个公钥对这个仓库进行验证。一般来说不同作者的项目公钥都不同，建议不要将用于验证的公钥设置为全局。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git config <span class="keyword">user</span>.signingkey <span class="variable">&lt;key ID&gt;</span></div></pre></td></tr></table></figure>
<p>然后可以像下面这样验证一个提交。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git verify-<span class="keyword">commit</span> &lt;<span class="keyword">commit</span> <span class="keyword">ID</span>&gt;</div></pre></td></tr></table></figure>
<p>或者验证一个标签。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="keyword">tag</span> <span class="title">-v</span> <span class="tag">&lt;tag&gt;</span></div></pre></td></tr></table></figure>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><h3 id="签名和验证"><a href="#签名和验证" class="headerlink" title="签名和验证"></a>签名和验证</h3><table>
<thead>
<tr>
<th>动作</th>
<th>指令</th>
</tr>
</thead>
<tbody>
<tr>
<td>二进制方式签名文件</td>
<td><code>gpg -u &lt;key ID&gt; -s &lt;file&gt;</code></td>
</tr>
<tr>
<td>纯文本方式签名文件</td>
<td><code>gpg -u &lt;key ID&gt; --clearsign &lt;file&gt;</code></td>
</tr>
<tr>
<td>签名文件并独立存放签名</td>
<td><code>gpg -u &lt;key ID&gt; --detach-sign &lt;file&gt;</code></td>
</tr>
<tr>
<td>验证文件</td>
<td><code>gpg --verify-files &lt;file&gt;</code></td>
</tr>
<tr>
<td>通过独立的签名文件验证文件</td>
<td><code>gpg --verify-files &lt;file_sig&gt; &lt;file&gt;</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>如果不指定<code>-u</code> 选项，会使用第一个密钥环中主钥的私钥进行签名。</p>
</blockquote>
<h3 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h3><table>
<thead>
<tr>
<th>动作</th>
<th>指令</th>
</tr>
</thead>
<tbody>
<tr>
<td>二进制方式加密文件</td>
<td><code>gpg -r &lt;key ID&gt; -e &lt;file&gt;</code></td>
</tr>
<tr>
<td>纯文本方式加密文件</td>
<td><code>gpg -r &lt;key ID&gt; -a -e &lt;file&gt;</code></td>
</tr>
<tr>
<td>解密文件</td>
<td><code>gpg &lt;file&gt;</code></td>
</tr>
</tbody>
</table>
<blockquote>
<ol>
<li>这里你需要指定从钥的钥匙号，如果<code>-r</code> 选项被省略，GPG 会交互式的请求一个钥匙号。</li>
<li>如果你想在加密的同时签名文件，在加密指令中额外指定一个<code>-s</code> 选项。</li>
</ol>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[计算IP、ICMP、TCP和UDP包的校验和]]></title>
      <url>https://arondight.github.io/2016/03/22/%E8%AE%A1%E7%AE%97IP%E3%80%81ICMP%E3%80%81TCP%E5%92%8CUDP%E5%8C%85%E7%9A%84%E6%A0%A1%E9%AA%8C%E5%92%8C/</url>
      <content type="html"><![CDATA[<h2 id="校验和算法"><a href="#校验和算法" class="headerlink" title="校验和算法"></a>校验和算法</h2><p>校验和的计算方法在文档<a href="https://tools.ietf.org/html/rfc1071" target="_blank" rel="external">RFC 1071</a> 中有如下说明：</p>
<blockquote>
<p>(1)  Adjacent octets to be checksummed are paired to form 16-bit<br>     integers, and the 1’s complement sum of these 16-bit integers is<br>     formed.</p>
<p>(2)  To generate a checksum, the checksum field itself is cleared,<br>     the 16-bit 1’s complement sum is computed over the octets<br>     concerned, and the 1’s complement of this sum is placed in the<br>     checksum field.</p>
</blockquote>
<a id="more"></a>
<p>即首先将校验和字段清零，将待求和数据调整为偶数字节（如为奇数字节则最后一个字节扩展为字）。然后用反码相加法（进位加到低位上）、以字为单位累加待求和数据。最后将累加结果取反并截低16 位作为校验和。</p>
<blockquote>
<p>之所以使用反码相加法，是为了让计算结果和网络序或主机序无关。</p>
</blockquote>
<p>根据这个规则，计算校验和的的C 语言函数可以做如下实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">uint16_t</span></div><div class="line">GetChecksum (<span class="keyword">const</span> <span class="keyword">void</span> * <span class="keyword">const</span> addr, <span class="keyword">const</span> <span class="keyword">size_t</span> bytes)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">uint16_t</span> *word;</div><div class="line">  <span class="keyword">uint32_t</span> sum;</div><div class="line">  <span class="keyword">uint16_t</span> checksum;</div><div class="line">  <span class="keyword">size_t</span> nleft;</div><div class="line"></div><div class="line">  assert (addr);</div><div class="line">  assert (bytes &gt; <span class="number">8</span> - <span class="number">1</span>);</div><div class="line"></div><div class="line">  word = (<span class="keyword">const</span> <span class="keyword">uint16_t</span> *)addr;</div><div class="line">  nleft = bytes;</div><div class="line"></div><div class="line">  <span class="comment">/* 使用32 位累加器，顺序累加16 位数据，进位保存在高16 位 */</span></div><div class="line">  <span class="keyword">for</span> (sum = <span class="number">0</span>; nleft &gt; <span class="number">1</span>; nleft -=<span class="number">2</span>)</div><div class="line">    &#123;</div><div class="line">      sum += *word;</div><div class="line">      ++word;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* 如果总字节为奇数则处理最后一个字节 */</span></div><div class="line">  sum += nleft ? *(<span class="keyword">uint8_t</span> *)word : <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="comment">/* 将进位加到低16 位，并将本次计算产生的进位再次加到低16 位 */</span></div><div class="line">  sum = (sum &gt;&gt; <span class="number">16</span>) + (sum &amp; <span class="number">0xffff</span>);</div><div class="line">  sum += (sum &gt;&gt; <span class="number">16</span>);</div><div class="line"></div><div class="line">  <span class="comment">/* 结果取反并截低16 位为校验和 */</span></div><div class="line">  <span class="keyword">return</span> checksum = ~sum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面会使用这个校验和计算函数分别计算IP、ICMP、TCP和UDP 包的校验和。</p>
<h2 id="IP-包校验和的计算"><a href="#IP-包校验和的计算" class="headerlink" title="IP 包校验和的计算"></a>IP 包校验和的计算</h2><p>IP 包校验和的计算范围在<a href="https://tools.ietf.org/html/rfc791" target="_blank" rel="external">RFC 791</a> 中有如下说明：</p>
<blockquote>
<p>   The checksum field is the 16 bit one’s complement of the one’s<br>   complement sum of all 16 bit words in the header.  For purposes of<br>   computing the checksum, the value of the checksum field is zero.</p>
</blockquote>
<p>即IP 包的校验和只计算包头。</p>
<p>根据描述，IP 包的校验和可用C 语言做如下计算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> iphdr *ipheader;</div><div class="line"></div><div class="line">ipheader = (<span class="keyword">struct</span> iphdr *)packet;</div><div class="line"></div><div class="line"><span class="comment">/* 填充ipheader... */</span></div><div class="line"></div><div class="line"><span class="comment">/* 计算该IP 包校验和 */</span></div><div class="line">ipheader-&gt;check = <span class="number">0</span>;</div><div class="line">ipheader-&gt;check = GetChecksum (ipheader, <span class="keyword">sizeof</span> (<span class="keyword">struct</span> iphdr));</div></pre></td></tr></table></figure>
<h2 id="ICMP-包校验和的计算"><a href="#ICMP-包校验和的计算" class="headerlink" title="ICMP 包校验和的计算"></a>ICMP 包校验和的计算</h2><p>ICMP 包校验和的计算范围在<a href="https://tools.ietf.org/html/rfc792" target="_blank" rel="external">RFC 792</a> 中有如下说明：</p>
<blockquote>
<p>   The checksum is the 16-bit ones’s complement of the one’s<br>   complement sum of the ICMP message starting with the ICMP Type.<br>   For computing the checksum , the checksum field should be zero.<br>   This checksum may be replaced in the future.</p>
</blockquote>
<p>即ICMP 包的计算范围包括包头和数据。</p>
<p>根据描述，假设IP 包校验和已经计算完毕，那么其中的ICMP 包校验和可以用C 语言做如下计算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> icmphdr *icmpheader;</div><div class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> ipheaderSize = <span class="keyword">sizeof</span> (<span class="keyword">struct</span> iphdr);</div><div class="line"></div><div class="line">icmpheader = (<span class="keyword">struct</span> icmphdr *)(packet + ipheaderSize);</div><div class="line"></div><div class="line"><span class="comment">/* 填充icmpheader... */</span></div><div class="line"></div><div class="line"><span class="comment">/* 计算该ICMP 包校验和 */</span></div><div class="line">icmpheader-&gt;checksum = <span class="number">0</span>;</div><div class="line">icmpheader-&gt;checksum = GetChecksum (icmpheader, packetSize - ipheaderSize);</div></pre></td></tr></table></figure>
<h2 id="TCP-和UDP-包校验和的计算"><a href="#TCP-和UDP-包校验和的计算" class="headerlink" title="TCP 和UDP 包校验和的计算"></a>TCP 和UDP 包校验和的计算</h2><h3 id="伪首部"><a href="#伪首部" class="headerlink" title="伪首部"></a>伪首部</h3><p>TCP 和UDP 校验和的计算要稍微麻烦一些，因为需要引入一个伪首部（pseudo header），伪首部的结构在<a href="https://tools.ietf.org/html/rfc768" target="_blank" rel="external">RFC 768</a> 中有如下说明：</p>
<blockquote>
<p> The pseudo  header  conceptually prefixed to the UDP header contains the<br> source  address,  the destination  address,  the protocol,  and the  UDP<br> length.   This information gives protection against misrouted datagrams.<br> This checksum procedure is the same as is used in TCP.</p>
<pre><code> 0      7 8     15 16    23 24    31
+--------+--------+--------+--------+
|          source address           |
+--------+--------+--------+--------+
|        destination address        |
+--------+--------+--------+--------+
|  zero  |protocol|   UDP length    |
+--------+--------+--------+--------+
</code></pre></blockquote>
<p>可见TCP 和UDP 的伪首部结构完全一致。</p>
<p>根据描述，伪首部的结构可以用C 语言结构体做如下实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> pseudohdr</div><div class="line">&#123;</div><div class="line">  <span class="keyword">uint32_t</span> src;</div><div class="line">  <span class="keyword">uint32_t</span> dst;</div><div class="line">  <span class="keyword">uint8_t</span> zero;</div><div class="line">  <span class="keyword">uint8_t</span> protocol;</div><div class="line">  <span class="keyword">uint16_t</span> len;</div><div class="line">&#125; <span class="keyword">pseudohdr_t</span>;</div></pre></td></tr></table></figure>
<h3 id="TCP-包校验和的计算"><a href="#TCP-包校验和的计算" class="headerlink" title="TCP 包校验和的计算"></a>TCP 包校验和的计算</h3><p>TCP 包校验和的计算方法在<a href="https://tools.ietf.org/html/rfc793" target="_blank" rel="external">RFC 793</a> 中有如下说明：</p>
<blockquote>
<p> The checksum field is the 16 bit one’s complement of the one’s<br> complement sum of all 16 bit words in the header and text.  If a<br> segment contains an odd number of header and text octets to be<br> checksummed, the last octet is padded on the right with zeros to<br> form a 16 bit word for checksum purposes.  The pad is not<br> transmitted as part of the segment.  While computing the checksum,<br> the checksum field itself is replaced with zeros.</p>
<p>   The checksum also covers a 96 bit pseudo header conceptually</p>
</blockquote>
<p>可见，算法和之前提到的校验和算法完全一致，根据描述校验和的计算需要包含伪首部和整个TCP 包。</p>
<p>根据描述，假设IP 包校验和已经计算完毕，那么其中的TCP 包校验和可以用C 语言做如下计算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *tcpsumblock;          <span class="comment">/* 伪首部 + TCP 头 + 数据 */</span></div><div class="line"><span class="keyword">struct</span> iphdr *ipheader;</div><div class="line"><span class="keyword">struct</span> tcphdr *tcpheader;</div><div class="line"><span class="keyword">pseudohdr_t</span> pseudoheader;</div><div class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> ipheaderSize = (<span class="keyword">struct</span> iphdr *)packet;</div><div class="line"></div><div class="line">ipheader = (<span class="keyword">struct</span> iphdr *)packet;</div><div class="line">tcpheader = (<span class="keyword">struct</span> tcphdr *)(packet + ipheaderSize);</div><div class="line"></div><div class="line"><span class="comment">/* 填充tcpheader... */</span></div><div class="line"></div><div class="line"><span class="comment">/* 填充pseudoheader */</span></div><div class="line">pseudoheader.src = ipheader-&gt;saddr;</div><div class="line">pseudoheader.dst = ipheader-&gt;daddr;</div><div class="line">pseudoheader.zero = <span class="number">0</span>;</div><div class="line">pseudoheader.protocol = ipheader-&gt;protocol;</div><div class="line">pseudoheader.len = htons (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> tcphdr));</div><div class="line"></div><div class="line"><span class="comment">/* 填充tcpsumblock */</span></div><div class="line">tcpheader-&gt;check = <span class="number">0</span>;</div><div class="line">tcpsumblock = (<span class="keyword">char</span> *)<span class="built_in">malloc</span> (packetSize);</div><div class="line"><span class="built_in">memcpy</span> (tcpsumblock, &amp;pseudoheader, <span class="keyword">sizeof</span> (<span class="keyword">pseudohdr_t</span>));</div><div class="line"><span class="built_in">memcpy</span> (tcpsumblock + <span class="keyword">sizeof</span> (<span class="keyword">pseudohdr_t</span>), packet, packetSize);</div><div class="line"></div><div class="line"><span class="comment">/* 计算TCP 包校验和 */</span></div><div class="line">tcpheader-&gt;check =</div><div class="line">  GetChecksum (tcpsumblock, <span class="keyword">sizeof</span> (<span class="keyword">pseudohdr_t</span>) + packetSize - ipheaderSize);</div><div class="line"></div><div class="line"><span class="built_in">free</span> (tcpsumblock);</div><div class="line">tcpsumblock = <span class="literal">NULL</span>;</div></pre></td></tr></table></figure>
<h3 id="UDP-包校验和的计算"><a href="#UDP-包校验和的计算" class="headerlink" title="UDP 包校验和的计算"></a>UDP 包校验和的计算</h3><p>UDP 包校验和的计算方法在<a href="https://tools.ietf.org/html/rfc768" target="_blank" rel="external">RFC 768</a> 中有如下说明：</p>
<blockquote>
<p> Checksum is the 16-bit one’s complement of the one’s complement sum of a<br> pseudo header of information from the IP header, the UDP header, and the<br> data,  padded  with zero octets  at the end (if  necessary)  to  make  a<br> multiple of two octets.</p>
<p>The pseudo  header  conceptually prefixed to the UDP header contains the<br>source  address,  the destination  address,  the protocol,  and the  UDP<br>length.   This information gives protection against misrouted datagrams.<br>This checksum procedure is the same as is used in TCP.</p>
</blockquote>
<p>所以UDP 包校验和的计算方法和TCP 包如出一辙，同样包含了一个伪首部。</p>
<p>具体的实现可以参考之前计算TCP 包校验的C 语言实现。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用SSH反向隧道进行内网穿透]]></title>
      <url>https://arondight.github.io/2016/02/17/%E4%BD%BF%E7%94%A8SSH%E5%8F%8D%E5%90%91%E9%9A%A7%E9%81%93%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
      <content type="html"><![CDATA[<h2 id="对应的情况"><a href="#对应的情况" class="headerlink" title="对应的情况"></a>对应的情况</h2><p>这篇文章主要介绍了如何利用SSH 反向隧道穿透NAT，并演示了如何维持一条稳定的SSH 隧道。</p>
<p>假设有机器A 和B，A 有公网IP，B 位于NAT 之后并无可用的端口转发，现在想由A 主动向B 发起SSH 连接。由于B 在NAT 后端，无可用<strong>公网IP + 端口</strong> 这样一个组合，所以A 无法穿透NAT，这篇文章应对的就是这种情况。</p>
<p>首先有如下约定，因为很重要所以放在前面：</p>
<table>
<thead>
<tr>
<th>机器代号</th>
<th>机器位置</th>
<th>地址</th>
<th>账户</th>
<th>ssh/sshd 端口</th>
<th>是否需要运行sshd</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>位于公网</td>
<td>a.site</td>
<td>usera</td>
<td>22</td>
<td>是</td>
</tr>
<tr>
<td>B</td>
<td>位于NAT 之后</td>
<td>localhost</td>
<td>userb</td>
<td>22</td>
<td>是</td>
</tr>
<tr>
<td>C</td>
<td>位于NAT 之后</td>
<td>localhost</td>
<td>userc</td>
<td>22</td>
<td>否</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<blockquote>
<p>这里默认你的系统init 程序为<code>systemd</code>，如果你使用其他的init 程序，如果没有特殊理由还是换到一个现代化的GNU/Linux 系统吧……</p>
</blockquote>
<h2 id="SSH-反向隧道"><a href="#SSH-反向隧道" class="headerlink" title="SSH 反向隧道"></a>SSH 反向隧道</h2><p>这种手段实质上是由B 向A 主动地建立一个SSH 隧道，将A 的6766 端口转发到B 的22 端口上，只要这条隧道不关闭，这个转发就是有效的。有了这个端口转发，只需要访问A 的6766 端口反向连接B 即可。</p>
<p>首先在<strong>B</strong> 上建立一个SSH 隧道，将A 的6766 端口转发到B 的22 端口上：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">B $ ssh -<span class="selector-tag">p</span> <span class="number">22</span> -qngfNTR <span class="number">6766</span>:localhost:<span class="number">22</span> usera@<span class="selector-tag">a</span>.site</div></pre></td></tr></table></figure>
<p>然后在<strong>A</strong> 上利用6766 端口反向SSH 到B：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A <span class="variable">$ </span>ssh -p <span class="number">6766</span> userb<span class="variable">@localhost</span></div></pre></td></tr></table></figure>
<p>要做的事情其实就是这么简单。</p>
<h2 id="隧道的维持"><a href="#隧道的维持" class="headerlink" title="隧道的维持"></a>隧道的维持</h2><h3 id="稳定性维持"><a href="#稳定性维持" class="headerlink" title="稳定性维持"></a>稳定性维持</h3><p>然而不幸的是SSH 连接是会超时关闭的，如果连接关闭，隧道无法维持，那么A 就无法利用反向隧道穿透B 所在的NAT 了，为此我们需要一种方案来提供一条稳定的SSH 反向隧道。</p>
<p>一个最简单的方法就是<code>autossh</code>，这个软件会在超时之后自动重新建立SSH 隧道，这样就解决了隧道的稳定性问题，如果你使用<a href="https://www.archlinux.org" target="_blank" rel="external">Arch Linux</a>，你可以这样获得它：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>sudo pacman -S autossh</div></pre></td></tr></table></figure>
<p>下面在<strong>B</strong> 上做之前类似的事情，不同的是该隧道会由<code>autossh</code> 来维持：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">B $ autossh -<span class="selector-tag">p</span> <span class="number">22</span> -M <span class="number">6777</span> -NR <span class="number">6766</span>:localhost:<span class="number">22</span> usera@<span class="selector-tag">a</span>.site</div></pre></td></tr></table></figure>
<p><code>-M</code> 参数指定的端口用来监听隧道的状态，与端口转发无关。</p>
<p>之后你可以在A 上通过6766 端口访问B 了：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A <span class="variable">$ </span>ssh -p <span class="number">6766</span> userb<span class="variable">@localhost</span></div></pre></td></tr></table></figure>
<h3 id="隧道的自动建立"><a href="#隧道的自动建立" class="headerlink" title="隧道的自动建立"></a>隧道的自动建立</h3><p>然而这又有了另外一个问题，如果B 重启隧道就会消失。那么需要有一种手段在B 每次启动时使用<code>autossh</code> 来建立SSH 隧道。很自然的一个想法就是做成服务，之后会给出在<code>systemd</code> 下的一种解决方案。</p>
<h2 id="“打洞”"><a href="#“打洞”" class="headerlink" title="“打洞”"></a>“打洞”</h2><p>之所以标题这么起，是因为自己觉得这件事情有点类似于UDP 打洞，即通过一台在公网的机器，让两台分别位于各自NAT 之后的机器可以建立SSH 连接。</p>
<p>下面演示如何使用SSH 反向隧道，让C 连接到B。</p>
<p>首先在<strong>A</strong> 上编辑<code>sshd</code> 的配置文件<code>/etc/ssh/sshd_config</code>，将<code>GatewayPorts</code> 开关打开：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">GatewayPorts</span> <span class="literal">yes</span></div></pre></td></tr></table></figure>
<p>然后重启<code>sshd</code>：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">A</span> $ sudo systemctl restart sshd</div></pre></td></tr></table></figure>
<p>然后在<strong>B</strong> 上对之前用到的<code>autossh</code> 指令略加修改：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">B $ autossh -<span class="selector-tag">p</span> <span class="number">22</span> -M <span class="number">6777</span> -NR <span class="string">'*:6766:localhost:22'</span> usera@<span class="selector-tag">a</span>.site</div></pre></td></tr></table></figure>
<p>之后在<strong>C</strong> 上利用<strong>A</strong> 的6766 端口SSH 连接到<strong>B</strong>：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C $ ssh -<span class="selector-tag">p</span> <span class="number">6766</span> userb@<span class="selector-tag">a</span>.site</div></pre></td></tr></table></figure>
<p>至此你已经轻而易举的穿透了两层NAT。</p>
<h2 id="最终的解决方案"><a href="#最终的解决方案" class="headerlink" title="最终的解决方案"></a>最终的解决方案</h2><p>整合一下前面提到的，最终的解决方案如下：</p>
<p>首先打开<strong>A</strong> 上<code>sshd</code> 的<code>GatewayPorts</code> 开关，并重启<code>sshd</code>（如有需要）。</p>
<p>然后在<strong>B</strong> 上新建一个用户<em>autossh</em>，根据权限最小化思想，B 上的<code>autossh</code> 服务将以<em>autossh</em> 用户的身份运行，以尽大可能避免出现安全问题：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">B </span>$ sudo useradd -m autossh</div><div class="line"><span class="keyword">B </span>$ sudo passwd autossh</div></pre></td></tr></table></figure>
<p>紧接着在<strong>B</strong> 上为<em>autossh</em> 用户创建SSH 密钥，并上传到A：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">B <span class="variable">$ </span>su - autossh</div><div class="line">B <span class="variable">$ </span>ssh-keygen -t <span class="string">'rsa'</span> -C <span class="string">'autossh@B'</span></div><div class="line">B <span class="variable">$ </span>ssh-copy-id usera<span class="variable">@a</span>.site</div></pre></td></tr></table></figure>
<p>注意该<strong>密钥不要设置密码</strong>，也就是运行<code>ssh-keygen</code> 指令时尽管一路回车，不要输入额外的字符。</p>
<p>然后在<strong>B</strong> 上创建以<em>autossh</em> 用户权限调用<code>autossh</code> 的service 文件。将下面文本写入到文件<code>/lib/systemd/system/autossh.service</code>，并设置权限为644：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="section">[Unit]</span></div><div class="line"><span class="attr">Description</span>=Auto SSH Tunnel</div><div class="line"><span class="attr">After</span>=network-<span class="literal">on</span>line.target</div><div class="line"><span class="section"></span></div><div class="line">[Service]</div><div class="line"><span class="attr">User</span>=autossh</div><div class="line"><span class="attr">Type</span>=simple</div><div class="line"><span class="attr">ExecStart</span>=/bin/autossh -p <span class="number">22</span> -M <span class="number">6777</span> -NR <span class="string">'*:6766:localhost:22'</span> usera@a.site -i /home/autossh/.ssh/id_rsa</div><div class="line"><span class="attr">ExecReload</span>=/bin/kill -HUP <span class="variable">$MAINPID</span></div><div class="line"><span class="attr">KillMode</span>=process</div><div class="line"><span class="attr">Restart</span>=always</div><div class="line"><span class="section"></span></div><div class="line">[Install]</div><div class="line"><span class="attr">WantedBy</span>=multi-user.target</div><div class="line"><span class="attr">WantedBy</span>=graphical.target</div></pre></td></tr></table></figure>
<p>在B 上让<code>network-online.target</code> 生效：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">B $ systemctl <span class="keyword">enable</span> NetworkManager-<span class="built_in">wait</span>-online</div></pre></td></tr></table></figure>
<blockquote>
<p>如果你使用<code>systemd-networkd</code>，你需要启用的服务则应当是<code>systemd-networkd-wait-online</code> 。</p>
</blockquote>
<p>然后设置该服务自动启动：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">B $ sudo systemctl <span class="built_in">enable</span> autossh</div></pre></td></tr></table></figure>
<p>如果你愿意，在这之后可以立刻启动它：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">B </span>$ sudo systemctl start autossh</div></pre></td></tr></table></figure>
<p>然后你可以在<strong>A</strong> 上使用这条反向隧道穿透B 所在的NAT SSH 连接到B：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A <span class="variable">$ </span>ssh -p <span class="number">6766</span> userb<span class="variable">@localhost</span></div></pre></td></tr></table></figure>
<p>或者是在<strong>C</strong> 上直接穿透两层NAT SSH 连接到B：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C $ ssh -<span class="selector-tag">p</span> <span class="number">6766</span> userb@<span class="selector-tag">a</span>.site</div></pre></td></tr></table></figure>
<p>如果你对SSH 足够熟悉，你可以利用这条隧道做更多的事情，例如你可以在反向连接时指定动态端口转发：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C $ ssh -<span class="selector-tag">p</span> <span class="number">6766</span> -qngfNTD <span class="number">7677</span> userb@<span class="selector-tag">a</span>.site</div></pre></td></tr></table></figure>
<p>假设<strong>C</strong> 是你家中的电脑，<strong>A</strong> 是你的VPS，<strong>B</strong> 是你公司的电脑。如果你这样做了，那么为浏览器设置端口为<code>7677</code> 的<code>sock4</code> 本地（localhost）代理后，你就可以在家里的浏览器上看到公司内网的网页。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[新年快乐]]></title>
      <url>https://arondight.github.io/2016/02/08/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90/</url>
      <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/usr/bin/env bash</span></div><div class="line"><span class="comment"># For Linux 3.10+ x86_64 and gcc 4.8+</span></div><div class="line">cat &lt;&lt;<span class="string">'By_Arondight'</span> | env gcc -xc -o .\ - - \</div><div class="line">&gt;/dev/null 2&gt;&amp;1 &amp;&amp; ./.\ - &amp;&amp; env rm .\ -</div><div class="line">char _[]=<span class="string">"\xe6\x96\xb0\xe5\xb9\xb4\xe5\xbf\xab\</span></div><div class="line">\xe4\xb9\x90\xef\xbc\x81\x0a";____(___)&lt;%putchar</div><div class="line">((___++)[_])&amp;&amp;____(___);_exit(0);%&gt;main()&lt;%long</div><div class="line">__=____;*(&amp;__+2)=__;__asm__(<span class="string">"\x78\x6f\x72\x71\x20\</span></div><div class="line">\x25\x72\x64\x69\x2c\x20\x25\x72\x64\x69\xa\x0");%&gt;</div><div class="line">By_Arondight</div></pre></td></tr></table></figure>
<p>惟愿可以遇到美好的人和事。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[随便写一点东西]]></title>
      <url>https://arondight.github.io/2016/01/03/%E9%9A%8F%E4%BE%BF%E5%86%99%E4%B8%80%E7%82%B9%E4%B8%9C%E8%A5%BF/</url>
      <content type="html"><![CDATA[<p>下午慢慢折腾了一下Hexo，然后成果就是这个博客。老实说我也不太清楚以后究竟在这上面会写点什么，多半会是所处的日常吧。</p>
<p>折腾完大约是下午接近4 点的样子，足足搞了快5 个小时。透过窄窄的窗子所看到的已经是很惨淡的阳光了。回过神来今天已经是公历新年后的第3 天了，或许因为最近1 个半月想了很多的事情，不知不觉已经将一年最后的时间消耗殆尽，不难过也不开心。</p>
<p>因为搞乱了生活节奏的原因，难得的假期里并没有什么新年的实感，没想过什么愿望，也没制定什么计划，不过依着心里还留存的一点点向往，希望以后能收获一些好的事物吧。</p>
]]></content>
    </entry>
    
  
  
</search>
