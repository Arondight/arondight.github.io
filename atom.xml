<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>河 的 第 三 条 岸</title>
  <subtitle>A Blog About Me</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://arondight.github.io/"/>
  <updated>2016-04-18T14:11:17.359Z</updated>
  <id>https://arondight.github.io/</id>
  
  <author>
    <name>Arondight</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用GPG签名Git提交和标签</title>
    <link href="https://arondight.github.io/2016/04/17/%E4%BD%BF%E7%94%A8GPG%E7%AD%BE%E5%90%8DGit%E6%8F%90%E4%BA%A4%E5%92%8C%E6%A0%87%E7%AD%BE/"/>
    <id>https://arondight.github.io/2016/04/17/使用GPG签名Git提交和标签/</id>
    <published>2016-04-17T06:16:53.000Z</published>
    <updated>2016-04-18T14:11:17.359Z</updated>
    
    <content type="html">&lt;h1 id=&quot;GPG-是什么&quot;&gt;&lt;a href=&quot;#GPG-是什么&quot; class=&quot;headerlink&quot; title=&quot;GPG 是什么&quot;&gt;&lt;/a&gt;GPG 是什么&lt;/h1&gt;&lt;p&gt;提GPG 之前需要提一个软件叫PGP。PGP 是“Pretty Good Privacy” 的缩写，名字言简意赅，上来就把软件的用途拍用户脸上。然而PGP 不是自由软件，所以自由软件基金会决定开发一个替代PGP 的自由软件，于是有了GPG（GnuPG）。&lt;/p&gt;
&lt;p&gt;GPG 可以提供对信息、文件的签名和验证，或者是加密和解密，主要用于不安全网络上的信息传输。为此GPG 需要一个密钥对，其中公钥单独可完成签名和验证，加密和解密则需要分别使用公钥和私钥来完成。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;签名&quot;&gt;&lt;a href=&quot;#签名&quot; class=&quot;headerlink&quot; title=&quot;签名&quot;&gt;&lt;/a&gt;签名&lt;/h1&gt;&lt;h2 id=&quot;生成公钥&quot;&gt;&lt;a href=&quot;#生成公钥&quot; class=&quot;headerlink&quot; title=&quot;生成公钥&quot;&gt;&lt;/a&gt;生成公钥&lt;/h2&gt;&lt;p&gt;首先需要生成一个GPG 公钥，GPG 在生成密钥的时候会使用一个根据你的操作生成的随机数，所以你可以在GPG 生成密钥的时候多做一些操作，例如点鼠标、敲键盘、复制文件等等。你可以利用&lt;code&gt;dd&lt;/code&gt; 指令在生成密钥的期间做一些读写操作以让随机数字发生器获得足够的熵数。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo dd &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;=/dev/random of=/dev/null bs=4M&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后可以生成GPG 密钥，推荐使用&lt;code&gt;--full-gen-key&lt;/code&gt; 选项来启用所有的功能。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;gpg --full-gen-key&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中需要注意的事情有以下几项：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;密钥种类：形如&lt;code&gt;method1 and method2&lt;/code&gt; 的选项是生成一个密钥对（公钥和私钥），可以用于签名/验证和加密/解密，如果你仅仅是为了签名而不想用于加密，可以使用一个形如&lt;code&gt;method&lt;/code&gt; 的选项（只生成公钥）。&lt;/li&gt;
&lt;li&gt;密钥长度：越长越安全，同时加密解密的时间花费越多，选择一个你认为合理的长度。&lt;/li&gt;
&lt;li&gt;有效期限：你需要选择一个你认为合理的有效期限，公钥到期后，签名将失效，GPG 服务器也会删除该公钥，所以一般来说你需要使用一个永不过期的公钥。&lt;/li&gt;
&lt;li&gt;密钥密码：一定要为你的密钥设置一个足够强壮的密码！&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;上传公钥到服务器&quot;&gt;&lt;a href=&quot;#上传公钥到服务器&quot; class=&quot;headerlink&quot; title=&quot;上传公钥到服务器&quot;&gt;&lt;/a&gt;上传公钥到服务器&lt;/h2&gt;&lt;p&gt;现在你可以将你的公钥上传到任意GPG 服务器上了，通过交换机制，全球所有的GPG 服务器都会得到你的公钥。你可以列出你现在所拥有的公钥。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;gpg --list-keys&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;根据用户名和邮箱，找到你之前生成的那个密钥。其中&lt;code&gt;pub&lt;/code&gt; 代表公钥，&lt;code&gt;sub&lt;/code&gt; 则是私钥。下面是一个样例输出。&lt;/p&gt;
&lt;figure class=&quot;highlight accesslog&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pub   rsa4096/B66CC194 &lt;span class=&quot;number&quot;&gt;2016&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;04&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;[SC]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;uid         &lt;span class=&quot;string&quot;&gt;[ 绝对 ]&lt;/span&gt; Arondight &amp;lt;shell_way@foxmail.com&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sub   rsa4096/F96E3CB7 &lt;span class=&quot;number&quot;&gt;2016&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;04&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;[E]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到一个算法为RSA、长度为4096、钥匙号（key ID）为&lt;code&gt;B66CC194&lt;/code&gt; 的公钥。找出公钥后，就可以上传这个公钥到GPG 服务器了。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;gpg --keyserver subkeys.pgp.net --send-keys &amp;lt;key ID&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;上传公钥到GitHub&quot;&gt;&lt;a href=&quot;#上传公钥到GitHub&quot; class=&quot;headerlink&quot; title=&quot;上传公钥到GitHub&quot;&gt;&lt;/a&gt;上传公钥到GitHub&lt;/h2&gt;&lt;p&gt;GitHub 刚刚发布了支持GPG 签名的消息，所以你可以选择使用GitHub 托管你的仓库。首先你需要以文本形式导出你的公钥。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;gpg &lt;span class=&quot;_&quot;&gt;-a&lt;/span&gt; -o gnupg.pub --export &amp;lt;key ID&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后打开你的GitHub &lt;a href=&quot;https://github.com/settings/keys&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;密钥管理&lt;/a&gt;界面，根据文件&lt;code&gt;gnupg.pub&lt;/code&gt; 为你的GitHub 账户配置公钥。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：这一步不是必须的，你不一定要使用GitHub，或许你更喜欢使用其他的商业产品，或者自己搭建一个Git 服务器。Git 本身就是支持GPG 签名的，GitHub 对GPG 的支持仅是把验证结果在网页上显示出来（使用你上传的公钥）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;导出指纹&quot;&gt;&lt;a href=&quot;#导出指纹&quot; class=&quot;headerlink&quot; title=&quot;导出指纹&quot;&gt;&lt;/a&gt;导出指纹&lt;/h2&gt;&lt;p&gt;然而不幸的是，任何人都可以冒充你的名义上传公钥到GPG 服务器，所以对方搜到以你的名义发布的公钥，不一定真的是你发布的。为了避免这个问题，你需要公布一个该公钥的指纹。GPG 导入公钥后必须手动设置信任度。这时候对方就可以通过对比手中公钥的指纹和你提供的指纹，来确定得到的公钥是否是你发布的公钥。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;LANG=en_US gpg --fingerprint &amp;lt;key ID&amp;gt; &amp;gt;fingerprint&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后将&lt;code&gt;fingerprint&lt;/code&gt; 文件提交到你的项目仓库中，或者公布在网络的其他位置。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：其实你可以通过&lt;code&gt;--export-ownertrust&lt;/code&gt; 和&lt;code&gt;--import-ownertrust&lt;/code&gt; 来直接导出和导入信任度，但是不推荐这样做。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;签名提交和标签&quot;&gt;&lt;a href=&quot;#签名提交和标签&quot; class=&quot;headerlink&quot; title=&quot;签名提交和标签&quot;&gt;&lt;/a&gt;签名提交和标签&lt;/h2&gt;&lt;p&gt;首先你需要为Git 设置一个用于签名的公钥，通常来说所有的个人项目都用一个公钥进行签名，所以建议设置为全局配置。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git config --global user.signingkey &amp;lt;key ID&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后就可以使用这个公钥来签名提交。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git commit -S&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;或者签名标签了。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git tag &lt;span class=&quot;_&quot;&gt;-s&lt;/span&gt; &amp;lt;tag&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;关于私钥&quot;&gt;&lt;a href=&quot;#关于私钥&quot; class=&quot;headerlink&quot; title=&quot;关于私钥&quot;&gt;&lt;/a&gt;关于私钥&lt;/h2&gt;&lt;p&gt;你可能注意到了，整个过程中我们都没有使用到私钥。之前也提到过，GPG 签名和验证的过程不需要私钥，私钥在解密过程中使用的。所以如果你生成了一个包含私钥的密钥对，任何情况向下都不要把私钥泄露给除了你之外的任何人。如果需要向对方发送加密信息，请让对方提供指纹，导入对方的公钥进行加密，而不要将自己的私钥发送过去。&lt;/p&gt;
&lt;h1 id=&quot;验证&quot;&gt;&lt;a href=&quot;#验证&quot; class=&quot;headerlink&quot; title=&quot;验证&quot;&gt;&lt;/a&gt;验证&lt;/h1&gt;&lt;h2 id=&quot;获得公钥&quot;&gt;&lt;a href=&quot;#获得公钥&quot; class=&quot;headerlink&quot; title=&quot;获得公钥&quot;&gt;&lt;/a&gt;获得公钥&lt;/h2&gt;&lt;p&gt;你可以根据你得到的信息在任何GPG 服务器上查找对应的公钥，典型的例如查看指纹，然后根据指纹到服务器上查找公钥。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;gpg --keyserver subkeys.pgp.net --search-keys &amp;lt;key ID&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;选择对应的编号，会自动下载并导入该公钥。&lt;/p&gt;
&lt;h2 id=&quot;设置信任&quot;&gt;&lt;a href=&quot;#设置信任&quot; class=&quot;headerlink&quot; title=&quot;设置信任&quot;&gt;&lt;/a&gt;设置信任&lt;/h2&gt;&lt;p&gt;导入后的公钥需要设置信任度才能使用该公钥进行验证，你可以通过类似下面的指令编辑该公钥的信息。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;gpg --edit-key &amp;lt;key ID&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你所看到的应该是一个文本交互界面，下面是一个样例。&lt;/p&gt;
&lt;figure class=&quot;highlight livescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;gpg (GnuPG) &lt;span class=&quot;number&quot;&gt;2.1&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;; Copyright (C) &lt;span class=&quot;number&quot;&gt;2016&lt;/span&gt; Free Software Foundation, Inc.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;This &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; free software: you are free &lt;span class=&quot;keyword&quot;&gt;to&lt;/span&gt; change &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; redistribute &lt;span class=&quot;literal&quot;&gt;it&lt;/span&gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;There &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; NO WARRANTY, &lt;span class=&quot;keyword&quot;&gt;to&lt;/span&gt; the extent permitted &lt;span class=&quot;keyword&quot;&gt;by&lt;/span&gt; law.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;私钥可用。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sec  rsa4096/B66CC194&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     创建于：&lt;span class=&quot;number&quot;&gt;2016&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;04&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;  有效至：永不过期  可用于：SC&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     信任度：绝对        有效性：绝对&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ssb  rsa4096/F96E3CB7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     创建于：&lt;span class=&quot;number&quot;&gt;2016&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;04&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;  有效至：永不过期  可用于：E&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[ 绝对 ] (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;). Arondight &amp;lt;shell_way@foxmail.com&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;gpg&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你可以键入&lt;code&gt;fpr&lt;/code&gt; 来打印这个公钥的指纹，和你得到的指纹进行对比，如果一致的话，那么键入&lt;code&gt;trust&lt;/code&gt; 来设置该密钥的信任度。最后键入&lt;code&gt;quit&lt;/code&gt; 退出。&lt;/p&gt;
&lt;h2 id=&quot;验证签名&quot;&gt;&lt;a href=&quot;#验证签名&quot; class=&quot;headerlink&quot; title=&quot;验证签名&quot;&gt;&lt;/a&gt;验证签名&lt;/h2&gt;&lt;p&gt;现在你可以用导入的公钥来验证你&lt;code&gt;git clone&lt;/code&gt; 下来的仓库的提交和标签了，同样你需要首先告诉Git 应该使用哪个公钥对这个仓库进行验证。一般来说不同作者的项目公钥都不同，建议不要将用于验证的公钥设置为全局。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git config user.signingkey &amp;lt;key ID&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后可以像下面这样验证一个提交。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git verify-commit HEAD&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;或者验证一个标签。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git tag -v &amp;lt;tag&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;扩展阅读&quot;&gt;&lt;a href=&quot;#扩展阅读&quot; class=&quot;headerlink&quot; title=&quot;扩展阅读&quot;&gt;&lt;/a&gt;扩展阅读&lt;/h1&gt;&lt;h2 id=&quot;签名和验证&quot;&gt;&lt;a href=&quot;#签名和验证&quot; class=&quot;headerlink&quot; title=&quot;签名和验证&quot;&gt;&lt;/a&gt;签名和验证&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;动作&lt;/th&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;二进制方式签名文件&lt;/td&gt;
&lt;td&gt;&lt;code&gt;gpg -u &amp;lt;key ID&amp;gt; -s file&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;纯文本方式签名文件&lt;/td&gt;
&lt;td&gt;&lt;code&gt;gpg -u &amp;lt;key ID&amp;gt; --clearsign file&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;签名文件并独立存放签名&lt;/td&gt;
&lt;td&gt;&lt;code&gt;gpg -u &amp;lt;key ID&amp;gt; --detach-sign file&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;验证文件&lt;/td&gt;
&lt;td&gt;&lt;code&gt;gpg --verify-files file&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;通过独立的签名文件验证文件&lt;/td&gt;
&lt;td&gt;&lt;code&gt;gpg --verify-files file.sig file&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;加密和解密&quot;&gt;&lt;a href=&quot;#加密和解密&quot; class=&quot;headerlink&quot; title=&quot;加密和解密&quot;&gt;&lt;/a&gt;加密和解密&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;动作&lt;/th&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;二进制方式加密文件&lt;/td&gt;
&lt;td&gt;&lt;code&gt;gpg -r &amp;lt;key ID&amp;gt; -e file&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;纯文本方式加密文件&lt;/td&gt;
&lt;td&gt;&lt;code&gt;gpg -r &amp;lt;key ID&amp;gt; -a -e file&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;解密文件&lt;/td&gt;
&lt;td&gt;&lt;code&gt;gpg file&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你想在加密的同时签名文件，在加密指令中额外指定一个&lt;code&gt;-s&lt;/code&gt; 选项。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;GPG-是什么&quot;&gt;&lt;a href=&quot;#GPG-是什么&quot; class=&quot;headerlink&quot; title=&quot;GPG 是什么&quot;&gt;&lt;/a&gt;GPG 是什么&lt;/h1&gt;&lt;p&gt;提GPG 之前需要提一个软件叫PGP。PGP 是“Pretty Good Privacy” 的缩写，名字言简意赅，上来就把软件的用途拍用户脸上。然而PGP 不是自由软件，所以自由软件基金会决定开发一个替代PGP 的自由软件，于是有了GPG（GnuPG）。&lt;/p&gt;
&lt;p&gt;GPG 可以提供对信息、文件的签名和验证，或者是加密和解密，主要用于不安全网络上的信息传输。为此GPG 需要一个密钥对，其中公钥单独可完成签名和验证，加密和解密则需要分别使用公钥和私钥来完成。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://arondight.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Git" scheme="https://arondight.github.io/tags/Git/"/>
    
      <category term="GPG" scheme="https://arondight.github.io/tags/GPG/"/>
    
      <category term="GitHub" scheme="https://arondight.github.io/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>计算IP、ICMP、TCP和UDP包的校验和</title>
    <link href="https://arondight.github.io/2016/03/22/%E8%AE%A1%E7%AE%97IP%E3%80%81ICMP%E3%80%81TCP%E5%92%8CUDP%E5%8C%85%E7%9A%84%E6%A0%A1%E9%AA%8C%E5%92%8C/"/>
    <id>https://arondight.github.io/2016/03/22/计算IP、ICMP、TCP和UDP包的校验和/</id>
    <published>2016-03-22T12:06:40.000Z</published>
    <updated>2016-04-14T17:34:48.240Z</updated>
    
    <content type="html">&lt;h1 id=&quot;校验和算法&quot;&gt;&lt;a href=&quot;#校验和算法&quot; class=&quot;headerlink&quot; title=&quot;校验和算法&quot;&gt;&lt;/a&gt;校验和算法&lt;/h1&gt;&lt;p&gt;校验和的计算方法在文档&lt;a href=&quot;https://tools.ietf.org/html/rfc1071&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RFC 1071&lt;/a&gt; 中有如下说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(1)  Adjacent octets to be checksummed are paired to form 16-bit&lt;br&gt;     integers, and the 1’s complement sum of these 16-bit integers is&lt;br&gt;     formed.&lt;/p&gt;
&lt;p&gt;(2)  To generate a checksum, the checksum field itself is cleared,&lt;br&gt;     the 16-bit 1’s complement sum is computed over the octets&lt;br&gt;     concerned, and the 1’s complement of this sum is placed in the&lt;br&gt;     checksum field.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;即首先将校验和字段清零，将待求和数据调整为偶数字节（如为奇数字节则最后一个字节扩展为字）。然后用反码相加法（进位加到低位上）、以字为单位累加待求和数据。最后将累加结果取反并截低16 位作为校验和。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;之所以使用反码相加法，是为了让计算结果和网络序或主机序无关。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据这个规则，计算校验和的的C 语言函数可以做如下实现。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;uint16_t&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;GetChecksum (&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; * &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; addr, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; bytes)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;uint16_t&lt;/span&gt; *word;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt; sum;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;uint16_t&lt;/span&gt; checksum;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; nleft;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  assert (addr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  assert (bytes &amp;gt; &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt; - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  word = (&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;uint16_t&lt;/span&gt; *)addr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  nleft = bytes;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/* 使用32 位累加器，顺序累加16 位数据，进位保存在高16 位 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (sum = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; nleft &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; nleft -=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      sum += *word;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      ++word;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/* 如果总字节为奇数则处理最后一个字节 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  sum += nleft ? *(&lt;span class=&quot;keyword&quot;&gt;uint8_t&lt;/span&gt; *)word : &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/* 将进位加到低16 位，并将本次计算产生的进位再次加到低16 位 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  sum = (sum &amp;gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;) + (sum &amp;amp; &lt;span class=&quot;number&quot;&gt;0xffff&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  sum += (sum &amp;gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/* 结果取反并截低16 位为校验和 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; checksum = ~sum;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面会使用这个校验和计算函数分别计算IP、ICMP、TCP和UDP 包的校验和。&lt;/p&gt;
&lt;h1 id=&quot;IP-包校验和的计算&quot;&gt;&lt;a href=&quot;#IP-包校验和的计算&quot; class=&quot;headerlink&quot; title=&quot;IP 包校验和的计算&quot;&gt;&lt;/a&gt;IP 包校验和的计算&lt;/h1&gt;&lt;p&gt;IP 包校验和的计算范围在&lt;a href=&quot;https://tools.ietf.org/html/rfc791&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RFC 791&lt;/a&gt; 中有如下说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;   The checksum field is the 16 bit one’s complement of the one’s&lt;br&gt;   complement sum of all 16 bit words in the header.  For purposes of&lt;br&gt;   computing the checksum, the value of the checksum field is zero.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;即IP 包的校验和只计算包头。&lt;/p&gt;
&lt;p&gt;根据描述，IP 包的校验和可用C 语言做如下计算。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; iphdr *ipheader;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ipheader = (&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; iphdr *)packet;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 填充ipheader... */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 计算该IP 包校验和 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ipheader-&amp;gt;check = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ipheader-&amp;gt;check = GetChecksum (ipheader, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; iphdr));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;ICMP-包校验和的计算&quot;&gt;&lt;a href=&quot;#ICMP-包校验和的计算&quot; class=&quot;headerlink&quot; title=&quot;ICMP 包校验和的计算&quot;&gt;&lt;/a&gt;ICMP 包校验和的计算&lt;/h1&gt;&lt;p&gt;ICMP 包校验和的计算范围在&lt;a href=&quot;https://tools.ietf.org/html/rfc792&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RFC 792&lt;/a&gt; 中有如下说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;   The checksum is the 16-bit ones’s complement of the one’s&lt;br&gt;   complement sum of the ICMP message starting with the ICMP Type.&lt;br&gt;   For computing the checksum , the checksum field should be zero.&lt;br&gt;   This checksum may be replaced in the future.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;即ICMP 包的计算范围包括包头和数据。&lt;/p&gt;
&lt;p&gt;根据描述，假设IP 包校验和已经计算完毕，那么其中的ICMP 包校验和可以用C 语言做如下计算。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; icmphdr *icmpheader;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; ipheaderSize = &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; iphdr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;icmpheader = (&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; icmphdr *)(packet + ipheaderSize);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 填充icmpheader... */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 计算该ICMP 包校验和 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;icmpheader-&amp;gt;checksum = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;icmpheader-&amp;gt;checksum = GetChecksum (icmpheader, packetSize - ipheaderSize);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;TCP-和UDP-包校验和的计算&quot;&gt;&lt;a href=&quot;#TCP-和UDP-包校验和的计算&quot; class=&quot;headerlink&quot; title=&quot;TCP 和UDP 包校验和的计算&quot;&gt;&lt;/a&gt;TCP 和UDP 包校验和的计算&lt;/h1&gt;&lt;h2 id=&quot;伪首部&quot;&gt;&lt;a href=&quot;#伪首部&quot; class=&quot;headerlink&quot; title=&quot;伪首部&quot;&gt;&lt;/a&gt;伪首部&lt;/h2&gt;&lt;p&gt;TCP 和UDP 校验和的计算要稍微麻烦一些，因为需要引入一个伪首部（pseudo header），伪首部的结构在&lt;a href=&quot;https://tools.ietf.org/html/rfc768&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RFC 768&lt;/a&gt; 中有如下说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; The pseudo  header  conceptually prefixed to the UDP header contains the&lt;br&gt; source  address,  the destination  address,  the protocol,  and the  UDP&lt;br&gt; length.   This information gives protection against misrouted datagrams.&lt;br&gt; This checksum procedure is the same as is used in TCP.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 0      7 8     15 16    23 24    31
+--------+--------+--------+--------+
|          source address           |
+--------+--------+--------+--------+
|        destination address        |
+--------+--------+--------+--------+
|  zero  |protocol|   UDP length    |
+--------+--------+--------+--------+
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;可见TCP 和UDP 的伪首部结构完全一致。&lt;/p&gt;
&lt;p&gt;根据描述，伪首部的结构可以用C 语言结构体做如下实现。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; pseudohdr&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt; src;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt; dst;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;uint8_t&lt;/span&gt; zero;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;uint8_t&lt;/span&gt; protocol;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;uint16_t&lt;/span&gt; len;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;pseudohdr_t&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;TCP-包校验和的计算&quot;&gt;&lt;a href=&quot;#TCP-包校验和的计算&quot; class=&quot;headerlink&quot; title=&quot;TCP 包校验和的计算&quot;&gt;&lt;/a&gt;TCP 包校验和的计算&lt;/h2&gt;&lt;p&gt;TCP 包校验和的计算方法在&lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RFC 793&lt;/a&gt; 中有如下说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; The checksum field is the 16 bit one’s complement of the one’s&lt;br&gt; complement sum of all 16 bit words in the header and text.  If a&lt;br&gt; segment contains an odd number of header and text octets to be&lt;br&gt; checksummed, the last octet is padded on the right with zeros to&lt;br&gt; form a 16 bit word for checksum purposes.  The pad is not&lt;br&gt; transmitted as part of the segment.  While computing the checksum,&lt;br&gt; the checksum field itself is replaced with zeros.&lt;/p&gt;
&lt;p&gt;   The checksum also covers a 96 bit pseudo header conceptually&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可见，算法和之前提到的校验和算法完全一致，根据描述校验和的计算需要包含伪首部和整个TCP 包。&lt;/p&gt;
&lt;p&gt;根据描述，假设IP 包校验和已经计算完毕，那么其中的TCP 包校验和可以用C 语言做如下计算。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *tcpsumblock;          &lt;span class=&quot;comment&quot;&gt;/* 伪首部 + TCP 头 + 数据 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; iphdr *ipheader;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; tcphdr *tcpheader;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;pseudohdr_t&lt;/span&gt; pseudoheader;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;size_t&lt;/span&gt; ipheaderSize = (&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; iphdr *)packet;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ipheader = (&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; iphdr *)packet;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tcpheader = (&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; tcphdr *)(packet + ipheaderSize);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 填充tcpheader... */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 填充pseudoheader */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pseudoheader.src = ipheader-&amp;gt;saddr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pseudoheader.dst = ipheader-&amp;gt;daddr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pseudoheader.zero = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pseudoheader.protocol = ipheader-&amp;gt;protocol;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pseudoheader.len = htons (&lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; tcphdr));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 填充tcpsumblock */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tcpheader-&amp;gt;check = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tcpsumblock = (&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *)&lt;span class=&quot;built_in&quot;&gt;malloc&lt;/span&gt; (packetSize);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;memcpy&lt;/span&gt; (tcpsumblock, &amp;amp;pseudoheader, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;pseudohdr_t&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;memcpy&lt;/span&gt; (tcpsumblock + &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;pseudohdr_t&lt;/span&gt;), packet, packetSize);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* 计算TCP 包校验和 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tcpheader-&amp;gt;check =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  GetChecksum (tcpsumblock, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;pseudohdr_t&lt;/span&gt;) + packetSize - ipheaderSize);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;free&lt;/span&gt; (tcpsumblock);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tcpsumblock = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;UDP-包校验和的计算&quot;&gt;&lt;a href=&quot;#UDP-包校验和的计算&quot; class=&quot;headerlink&quot; title=&quot;UDP 包校验和的计算&quot;&gt;&lt;/a&gt;UDP 包校验和的计算&lt;/h2&gt;&lt;p&gt;UDP 包校验和的计算方法在&lt;a href=&quot;https://tools.ietf.org/html/rfc768&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RFC 768&lt;/a&gt; 中有如下说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; Checksum is the 16-bit one’s complement of the one’s complement sum of a&lt;br&gt; pseudo header of information from the IP header, the UDP header, and the&lt;br&gt; data,  padded  with zero octets  at the end (if  necessary)  to  make  a&lt;br&gt; multiple of two octets.&lt;/p&gt;
&lt;p&gt;The pseudo  header  conceptually prefixed to the UDP header contains the&lt;br&gt;source  address,  the destination  address,  the protocol,  and the  UDP&lt;br&gt;length.   This information gives protection against misrouted datagrams.&lt;br&gt;This checksum procedure is the same as is used in TCP.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以UDP 包校验和的计算方法和TCP 包如出一辙，同样包含了一个伪首部。&lt;/p&gt;
&lt;p&gt;具体的实现可以参考之前计算TCP 包校验的C 语言实现。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;校验和算法&quot;&gt;&lt;a href=&quot;#校验和算法&quot; class=&quot;headerlink&quot; title=&quot;校验和算法&quot;&gt;&lt;/a&gt;校验和算法&lt;/h1&gt;&lt;p&gt;校验和的计算方法在文档&lt;a href=&quot;https://tools.ietf.org/html/rfc1071&quot;&gt;RFC 1071&lt;/a&gt; 中有如下说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(1)  Adjacent octets to be checksummed are paired to form 16-bit&lt;br&gt;     integers, and the 1’s complement sum of these 16-bit integers is&lt;br&gt;     formed.&lt;/p&gt;
&lt;p&gt;(2)  To generate a checksum, the checksum field itself is cleared,&lt;br&gt;     the 16-bit 1’s complement sum is computed over the octets&lt;br&gt;     concerned, and the 1’s complement of this sum is placed in the&lt;br&gt;     checksum field.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术" scheme="https://arondight.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="网络协议" scheme="https://arondight.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="IP" scheme="https://arondight.github.io/tags/IP/"/>
    
      <category term="TCP" scheme="https://arondight.github.io/tags/TCP/"/>
    
      <category term="ICMP" scheme="https://arondight.github.io/tags/ICMP/"/>
    
      <category term="UDP" scheme="https://arondight.github.io/tags/UDP/"/>
    
      <category term="校验和" scheme="https://arondight.github.io/tags/%E6%A0%A1%E9%AA%8C%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>使用SSH反向隧道进行内网穿透</title>
    <link href="https://arondight.github.io/2016/02/17/%E4%BD%BF%E7%94%A8SSH%E5%8F%8D%E5%90%91%E9%9A%A7%E9%81%93%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <id>https://arondight.github.io/2016/02/17/使用SSH反向隧道进行内网穿透/</id>
    <published>2016-02-17T10:09:57.000Z</published>
    <updated>2016-04-19T12:48:28.308Z</updated>
    
    <content type="html">&lt;h1 id=&quot;对应的情况&quot;&gt;&lt;a href=&quot;#对应的情况&quot; class=&quot;headerlink&quot; title=&quot;对应的情况&quot;&gt;&lt;/a&gt;对应的情况&lt;/h1&gt;&lt;p&gt;这篇文章主要介绍了如何利用SSH 反向隧道穿透NAT，并演示了如何维持一条稳定的SSH 隧道。&lt;/p&gt;
&lt;p&gt;假设有机器A 和B，A 有公网IP，B 位于NAT 之后并无可用的端口转发，现在想由A 主动向B 发起SSH 连接。由于B 在NAT 后端，无可用&lt;strong&gt;公网IP + 端口&lt;/strong&gt; 这样一个组合，所以A 无法穿透NAT，这篇文章应对的就是这种情况。&lt;/p&gt;
&lt;p&gt;首先有如下约定，因为很重要所以放在前面：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;机器代号&lt;/th&gt;
&lt;th&gt;机器位置&lt;/th&gt;
&lt;th&gt;地址&lt;/th&gt;
&lt;th&gt;账户&lt;/th&gt;
&lt;th&gt;ssh/sshd 端口&lt;/th&gt;
&lt;th&gt;是否需要运行sshd&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;位于公网&lt;/td&gt;
&lt;td&gt;a.site&lt;/td&gt;
&lt;td&gt;usera&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;位于NAT 之后&lt;/td&gt;
&lt;td&gt;b.localhost&lt;/td&gt;
&lt;td&gt;userb&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;位于NAT 之后&lt;/td&gt;
&lt;td&gt;c.localhost&lt;/td&gt;
&lt;td&gt;userc&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;这里默认你的系统init 程序为&lt;code&gt;systemd&lt;/code&gt;，如果你使用其他的init 程序，如果没有特殊理由还是换到一个现代化的GNU/Linux 系统吧……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;SSH-反向隧道&quot;&gt;&lt;a href=&quot;#SSH-反向隧道&quot; class=&quot;headerlink&quot; title=&quot;SSH 反向隧道&quot;&gt;&lt;/a&gt;SSH 反向隧道&lt;/h1&gt;&lt;p&gt;这种手段实质上是由B 向A 主动地建立一个SSH 隧道，将A 的6766 端口转发到B 的22 端口上，只要这条隧道不关闭，这个转发就是有效的。有了这个端口转发，只需要访问A 的6766 端口反向连接B 即可。&lt;/p&gt;
&lt;p&gt;首先在&lt;strong&gt;B&lt;/strong&gt; 上建立一个SSH 隧道，将A 的6766 端口转发到B 的22 端口上：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;B $ ssh -p 22 -qngfNTR 6766:b.localhost:22 usera@a.site&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后在&lt;strong&gt;A&lt;/strong&gt; 上利用6766 端口反向SSH 到B：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;A $ ssh -p 6766 userb@127.0.0.1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;要做的事情其实就是这么简单。&lt;/p&gt;
&lt;h1 id=&quot;隧道的维持&quot;&gt;&lt;a href=&quot;#隧道的维持&quot; class=&quot;headerlink&quot; title=&quot;隧道的维持&quot;&gt;&lt;/a&gt;隧道的维持&lt;/h1&gt;&lt;h2 id=&quot;稳定性维持&quot;&gt;&lt;a href=&quot;#稳定性维持&quot; class=&quot;headerlink&quot; title=&quot;稳定性维持&quot;&gt;&lt;/a&gt;稳定性维持&lt;/h2&gt;&lt;p&gt;然而不幸的是SSH 连接是会超时关闭的，如果连接关闭，隧道无法维持，那么A 就无法利用反向隧道穿透B 所在的NAT 了，为此我们需要一种方案来提供一条稳定的SSH 反向隧道。&lt;/p&gt;
&lt;p&gt;一个最简单的方法就是&lt;code&gt;autossh&lt;/code&gt;，这个软件会在超时之后自动重新建立SSH 隧道，这样就解决了隧道的稳定性问题，如果你使用&lt;a href=&quot;https://www.archlinux.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Arch Linux&lt;/a&gt;，你可以这样获得它：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo pacman -S autossh&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面在&lt;strong&gt;B&lt;/strong&gt; 上做之前类似的事情，不同的是该隧道会由&lt;code&gt;autossh&lt;/code&gt; 来维持：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;B $ autossh -p 22 -M 6777 -NR 6766:b.localhost:22 usera@a.site&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;-M&lt;/code&gt; 参数指定的端口用来监听隧道的状态，与端口转发无关。&lt;/p&gt;
&lt;p&gt;之后你可以在A 上通过6766 端口访问B 了：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;A $ ssh -p 6766 userb@127.0.0.1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;隧道的自动建立&quot;&gt;&lt;a href=&quot;#隧道的自动建立&quot; class=&quot;headerlink&quot; title=&quot;隧道的自动建立&quot;&gt;&lt;/a&gt;隧道的自动建立&lt;/h2&gt;&lt;p&gt;然而这又有了另外一个问题，如果B 重启隧道就会消失。那么需要有一种手段在B 每次启动时使用&lt;code&gt;autossh&lt;/code&gt; 来建立SSH 隧道。很自然的一个想法就是做成服务，之后会给出在&lt;code&gt;systemd&lt;/code&gt; 下的一种解决方案。&lt;/p&gt;
&lt;h1 id=&quot;“打洞”&quot;&gt;&lt;a href=&quot;#“打洞”&quot; class=&quot;headerlink&quot; title=&quot;“打洞”&quot;&gt;&lt;/a&gt;“打洞”&lt;/h1&gt;&lt;p&gt;之所以标题这么起，是因为自己觉得这件事情有点类似于UDP 打洞，即通过一台在公网的机器，让两台分别位于各自NAT 之后的机器可以建立SSH 连接。&lt;/p&gt;
&lt;p&gt;下面演示如何使用SSH 反向隧道，让C 连接到B。&lt;/p&gt;
&lt;p&gt;首先在&lt;strong&gt;A&lt;/strong&gt; 上编辑&lt;code&gt;sshd&lt;/code&gt; 的配置文件&lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt;，将&lt;code&gt;GatewayPorts&lt;/code&gt; 开关打开：&lt;/p&gt;
&lt;figure class=&quot;highlight nginx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;GatewayPorts&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;yes&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后重启&lt;code&gt;sshd&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;A $ sudo systemctl restart sshd&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后在&lt;strong&gt;B&lt;/strong&gt; 上对之前用到的&lt;code&gt;autossh&lt;/code&gt; 指令略加修改：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;B $ autossh -p 22 -M 6777 -NR &lt;span class=&quot;string&quot;&gt;&#39;*:6766:b.localhost:22&#39;&lt;/span&gt; usera@a.site&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;之后在&lt;strong&gt;C&lt;/strong&gt; 上利用&lt;strong&gt;A&lt;/strong&gt; 的6766 端口SSH 连接到&lt;strong&gt;B&lt;/strong&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;C $ ssh -p 6766 userb@a.site&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;至此你已经轻而易举的穿透了两层NAT。&lt;/p&gt;
&lt;h1 id=&quot;最终的解决方案&quot;&gt;&lt;a href=&quot;#最终的解决方案&quot; class=&quot;headerlink&quot; title=&quot;最终的解决方案&quot;&gt;&lt;/a&gt;最终的解决方案&lt;/h1&gt;&lt;p&gt;整合一下前面提到的，最终的解决方案如下：&lt;/p&gt;
&lt;p&gt;首先打开&lt;strong&gt;A&lt;/strong&gt; 上&lt;code&gt;sshd&lt;/code&gt; 的&lt;code&gt;GatewayPorts&lt;/code&gt; 开关，并重启&lt;code&gt;sshd&lt;/code&gt;（如有需要）。&lt;/p&gt;
&lt;p&gt;然后在&lt;strong&gt;B&lt;/strong&gt; 上新建一个用户&lt;em&gt;autossh&lt;/em&gt;，根据权限最小化思想，B 上的&lt;code&gt;autossh&lt;/code&gt; 服务将以&lt;em&gt;autossh&lt;/em&gt; 用户的身份运行，以尽大可能避免出现安全问题：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;B $ sudo useradd -m autossh&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;B $ sudo passwd autossh&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;紧接着在&lt;strong&gt;B&lt;/strong&gt; 上为&lt;em&gt;autossh&lt;/em&gt; 用户创建SSH 密钥，并上传到A：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;B $ su - autossh&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;B $ ssh-keygen -t &lt;span class=&quot;string&quot;&gt;&#39;rsa&#39;&lt;/span&gt; -C &lt;span class=&quot;string&quot;&gt;&#39;autossh@b.localhost&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;B $ ssh-copy-id usera@a.site&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意该&lt;strong&gt;密钥不要设置密码&lt;/strong&gt;，也就是运行&lt;code&gt;ssh-keygen&lt;/code&gt; 指令时尽管一路回车，不要输入额外的字符。&lt;/p&gt;
&lt;p&gt;然后在&lt;strong&gt;B&lt;/strong&gt; 上创建以&lt;em&gt;autossh&lt;/em&gt; 用户权限调用&lt;code&gt;autossh&lt;/code&gt; 的service 文件。将下面文本写入到文件&lt;code&gt;/lib/systemd/system/autossh.service&lt;/code&gt;，并设置权限为644：&lt;/p&gt;
&lt;figure class=&quot;highlight ini&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;[Unit]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;Description&lt;/span&gt;=Auto SSH Tunnel&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;After&lt;/span&gt;=network-&lt;span class=&quot;literal&quot;&gt;on&lt;/span&gt;line.target&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[Service]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;User&lt;/span&gt;=autossh&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;Type&lt;/span&gt;=simple&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;ExecStart&lt;/span&gt;=/bin/autossh -p &lt;span class=&quot;number&quot;&gt;22&lt;/span&gt; -M &lt;span class=&quot;number&quot;&gt;6777&lt;/span&gt; -NR &lt;span class=&quot;string&quot;&gt;&#39;*:6766:b.localhost:22&#39;&lt;/span&gt; usera@a.site -i /home/autossh/.ssh/id_rsa&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;ExecReload&lt;/span&gt;=/bin/kill -HUP &lt;span class=&quot;variable&quot;&gt;$MAINPID&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;KillMode&lt;/span&gt;=process&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;Restart&lt;/span&gt;=always&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;section&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[Install]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;WantedBy&lt;/span&gt;=multi-user.target&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;WantedBy&lt;/span&gt;=graphical.target&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在&lt;strong&gt;B&lt;/strong&gt; 上设置该服务自动启动：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;B $ sudo systemctl &lt;span class=&quot;built_in&quot;&gt;enable&lt;/span&gt; autossh&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你愿意，在这之后可以立刻启动它：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;B $ sudo systemctl start autossh&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后你可以在&lt;strong&gt;A&lt;/strong&gt; 上使用这条反向隧道穿透B 所在的NAT SSH 连接到B：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;A $ ssh -p 6766 userb@127.0.0.1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;或者是在&lt;strong&gt;C&lt;/strong&gt; 上直接穿透两层NAT SSH 连接到B：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;C $ ssh -p 6766 userb@a.site&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你对SSH 足够熟悉，你可以利用这条隧道做更多的事情，例如你可以在反向连接时指定动态端口转发：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;C $ ssh -p 6766 -qngfNTD 7677 userb@a.site&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;假设&lt;strong&gt;C&lt;/strong&gt; 是你家中的电脑，&lt;strong&gt;A&lt;/strong&gt; 是你的VPS，&lt;strong&gt;B&lt;/strong&gt; 是你公司的电脑。如果你这样做了，那么为浏览器设置端口为&lt;code&gt;7677&lt;/code&gt; 的&lt;code&gt;sock4&lt;/code&gt; 本地（127.0.0.1）代理后，你就可以在家里的浏览器上看到公司内网的网页。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;对应的情况&quot;&gt;&lt;a href=&quot;#对应的情况&quot; class=&quot;headerlink&quot; title=&quot;对应的情况&quot;&gt;&lt;/a&gt;对应的情况&lt;/h1&gt;&lt;p&gt;这篇文章主要介绍了如何利用SSH 反向隧道穿透NAT，并演示了如何维持一条稳定的SSH 隧道。&lt;/p&gt;
&lt;p&gt;假设有机器A 和B，A 有公网IP，B 位于NAT 之后并无可用的端口转发，现在想由A 主动向B 发起SSH 连接。由于B 在NAT 后端，无可用&lt;strong&gt;公网IP + 端口&lt;/strong&gt; 这样一个组合，所以A 无法穿透NAT，这篇文章应对的就是这种情况。&lt;/p&gt;
&lt;p&gt;首先有如下约定，因为很重要所以放在前面：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;机器代号&lt;/th&gt;
&lt;th&gt;机器位置&lt;/th&gt;
&lt;th&gt;地址&lt;/th&gt;
&lt;th&gt;账户&lt;/th&gt;
&lt;th&gt;ssh/sshd 端口&lt;/th&gt;
&lt;th&gt;是否需要运行sshd&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;位于公网&lt;/td&gt;
&lt;td&gt;a.site&lt;/td&gt;
&lt;td&gt;usera&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;位于NAT 之后&lt;/td&gt;
&lt;td&gt;b.localhost&lt;/td&gt;
&lt;td&gt;userb&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;位于NAT 之后&lt;/td&gt;
&lt;td&gt;c.localhost&lt;/td&gt;
&lt;td&gt;userc&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="技术" scheme="https://arondight.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="运维" scheme="https://arondight.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="内网穿透" scheme="https://arondight.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
      <category term="SSH" scheme="https://arondight.github.io/tags/SSH/"/>
    
      <category term="隧道" scheme="https://arondight.github.io/tags/%E9%9A%A7%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>新年快乐</title>
    <link href="https://arondight.github.io/2016/02/08/%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90/"/>
    <id>https://arondight.github.io/2016/02/08/新年快乐/</id>
    <published>2016-02-07T16:00:00.000Z</published>
    <updated>2016-04-14T17:34:48.240Z</updated>
    
    <content type="html">&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#!/usr/bin/env bash&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# For Linux 4.0+ x86_64&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cat &amp;lt;&amp;lt;&lt;span class=&quot;string&quot;&gt;&#39;By_Arondight&#39;&lt;/span&gt; | env gcc -xc -o .\ - - \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp;&amp;amp; ./.\ - &amp;amp;&amp;amp; env rm .\ -&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;char _[]=&lt;span class=&quot;string&quot;&gt;&quot;\xe6\x96\xb0\xe5\xb9\xb4\xe5\xbf\xab\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\xe4\xb9\x90\xef\xbc\x81\x0a&quot;&lt;/span&gt;;____(___)&amp;lt;%putchar&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;((___++)[_])&amp;amp;&amp;amp;____(___);_&lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt;(0);%&amp;gt;main()&amp;lt;%long&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;__=____;*(&amp;amp;__+2)=__;__asm__(&lt;span class=&quot;string&quot;&gt;&quot;\x78\x6f\x72\x71\x20\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\x25\x72\x64\x69\x2c\x20\x25\x72\x64\x69\xa\x0&quot;&lt;/span&gt;);%&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;By_Arondight&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;惟愿可以遇到美好的人和事。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
    
    </summary>
    
      <category term="节" scheme="https://arondight.github.io/categories/%E8%8A%82/"/>
    
    
      <category term="新年" scheme="https://arondight.github.io/tags/%E6%96%B0%E5%B9%B4/"/>
    
      <category term="C" scheme="https://arondight.github.io/tags/C/"/>
    
      <category term="Shell" scheme="https://arondight.github.io/tags/Shell/"/>
    
      <category term="汇编" scheme="https://arondight.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="溢出" scheme="https://arondight.github.io/tags/%E6%BA%A2%E5%87%BA/"/>
    
      <category term="栈帧" scheme="https://arondight.github.io/tags/%E6%A0%88%E5%B8%A7/"/>
    
  </entry>
  
  <entry>
    <title>软件和世界，愚者的中二之语</title>
    <link href="https://arondight.github.io/2016/01/10/%E8%BD%AF%E4%BB%B6%E5%92%8C%E4%B8%96%E7%95%8C%EF%BC%8C%E6%84%9A%E8%80%85%E7%9A%84%E4%B8%AD%E4%BA%8C%E4%B9%8B%E8%AF%AD/"/>
    <id>https://arondight.github.io/2016/01/10/软件和世界，愚者的中二之语/</id>
    <published>2016-01-10T11:24:11.000Z</published>
    <updated>2016-04-14T17:34:48.240Z</updated>
    
    <content type="html">&lt;p&gt;写这篇文章的现在心情有点糟，突然地被要求周末要去公司排练舞蹈，以后半个月也被不讲理地安排下班后加班排练，感觉自己完全把握不住自己的生活——作为一个程序员来说。&lt;/p&gt;
&lt;p&gt;从毕业到现在大约已经工作5 个月了，老实说，并没有什么令人激动的事情发生。虽然写的一部分代码也可以说正在被很多很多人使用着，然而我觉得这并没有让他们的生活发生什么变化。周遭的生活被工作夺走了，但是心中的期待并没有得到回应，虽然这么说有一点点不讲理，但是内心还是有一点失落的。&lt;/p&gt;
&lt;p&gt;以前我一直想写一个好的软件，当然现在也是，算起来的话从自己造一些小轮子开始就很向往这样的事情吧。“能遇到这个软件真的是太好了”，很想未来某天有人在用到我写的东西的时候也能诞生出这样的想法。说回来读过不少的书似乎都鼓励读者以写出“伟大的软件”为目标呢，但是这个概念一直在心中没有什么实感。而且“为什么我非要写一个伟大的软件呢”，没有什么特别的理由被想出。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;总觉得“好”和“伟大”之间有着不小的区别，但是我没办法很好地表达出这种区别，要说重要性的话当然是后者重要很多。但要问为什么自己会执着于一个不是很重要的目标，我能摊手么 X_X&lt;/p&gt;
&lt;p&gt;提两款这些年里遇到的“好的软件”吧：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Zygo/xscreensaver&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;XScreenSaver&lt;/a&gt;，一系列免费屏幕保护程序的集合，其中有一款名字叫&lt;a href=&quot;https://github.com/Zygo/xscreensaver/blob/master2/hacks/celtic.c&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Celtic&lt;/a&gt;，这是一个非常非常漂亮的屏幕保护程序，时常会盯着发呆很久的那种，有一种奇妙的美感。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jonls/redshift&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Redshift&lt;/a&gt;，一款能够根据经纬度计算昼夜时间，并根据这个时间平滑调整屏幕色温的软件，也是带有感激之情的一款软件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;伟大的软件也有很多，例如Linux，例如GCC，例如Xorg，例如nginx……然而只是觉得它们是很伟大的软件而已，并没有让内心感觉到特殊的感情。大约这就是“好”和“伟大”的区别，前者会让人觉得生活发生了一些好的改变，后者似乎因为伟大而成了一种必然的事物。&lt;/p&gt;
&lt;p&gt;这几年造了各种轮子，不少随着时间太久慢慢丢失了的，也有几个后来申请了个Github 挂在上面的，不过自己写的好的软件应该只有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Arondight/profile/tree/master/zsh/.zsh/ssh_env&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ssh-env&lt;/a&gt;，用来管理多套ssh 密钥的小脚本，这半年里带给自己日常生活很多方便。&lt;/li&gt;
&lt;li&gt;“电源盒子”，大约6 年前用GTK+ 写的一个小程序，用来关机、重启、睡眠或者关闭显示器，然而很多年前就已经遗失了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也造过很多其他的轮子，包括编码风格能让自己感到自豪的轮子，和代码量足足的轮子，但是都没有写上面提到的两个软件的那种奇妙的心情，也不会在以后用到的时候感觉“自己做了这个东西真的太好了”。&lt;/p&gt;
&lt;p&gt;这也是我一直没有实现的事情，写一个能够给很多人的生活带来好的改变的软件，或许以后可以实现，或许永远都实现不了，不过我还是有一点点期待，期待能够为肤色不同、语言相异的人们做一些有意义的事情。&lt;/p&gt;
&lt;p&gt;感觉自己可能一生都只会是一个平庸的程序员吧。伟大的程序员会去引导世界，写出伟大的软件，给其他的人们一种可能和方向。平庸的码农只能跟在其后搭积木，但如果搭出的东西能让这个世界中一些人们的日常生活发生一点好的改变的话，那样就真的太好了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;写这篇文章的现在心情有点糟，突然地被要求周末要去公司排练舞蹈，以后半个月也被不讲理地安排下班后加班排练，感觉自己完全把握不住自己的生活——作为一个程序员来说。&lt;/p&gt;
&lt;p&gt;从毕业到现在大约已经工作5 个月了，老实说，并没有什么令人激动的事情发生。虽然写的一部分代码也可以说正在被很多很多人使用着，然而我觉得这并没有让他们的生活发生什么变化。周遭的生活被工作夺走了，但是心中的期待并没有得到回应，虽然这么说有一点点不讲理，但是内心还是有一点失落的。&lt;/p&gt;
&lt;p&gt;以前我一直想写一个好的软件，当然现在也是，算起来的话从自己造一些小轮子开始就很向往这样的事情吧。“能遇到这个软件真的是太好了”，很想未来某天有人在用到我写的东西的时候也能诞生出这样的想法。说回来读过不少的书似乎都鼓励读者以写出“伟大的软件”为目标呢，但是这个概念一直在心中没有什么实感。而且“为什么我非要写一个伟大的软件呢”，没有什么特别的理由被想出。&lt;/p&gt;
    
    </summary>
    
      <category term="日常" scheme="https://arondight.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="随笔" scheme="https://arondight.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="中二" scheme="https://arondight.github.io/tags/%E4%B8%AD%E4%BA%8C/"/>
    
  </entry>
  
  <entry>
    <title>随便写一点东西</title>
    <link href="https://arondight.github.io/2016/01/03/%E9%9A%8F%E4%BE%BF%E5%86%99%E4%B8%80%E7%82%B9%E4%B8%9C%E8%A5%BF/"/>
    <id>https://arondight.github.io/2016/01/03/随便写一点东西/</id>
    <published>2016-01-03T07:34:18.000Z</published>
    <updated>2016-04-14T17:34:48.240Z</updated>
    
    <content type="html">&lt;p&gt;下午慢慢折腾了一下Hexo，然后成果就是这个博客。老实说我也不太清楚以后究竟在这上面会写点什么，多半会是所处的日常吧。&lt;/p&gt;
&lt;p&gt;折腾完大约是下午接近4 点的样子，足足搞了快5 个小时。透过窄窄的窗子所看到的已经是很惨淡的阳光了。回过神来今天已经是公历新年后的第3 天了，或许因为最近1 个半月想了很多的事情，不知不觉已经将一年最后的时间消耗殆尽，不难过也不开心。&lt;/p&gt;
&lt;p&gt;因为搞乱了生活节奏的原因，难得的假期里并没有什么新年的实感，没想过什么愿望，也没制定什么计划，不过依着心里还留存的一点点向往，希望以后能收获一些好的事物吧。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;下午慢慢折腾了一下Hexo，然后成果就是这个博客。老实说我也不太清楚以后究竟在这上面会写点什么，多半会是所处的日常吧。&lt;/p&gt;
&lt;p&gt;折腾完大约是下午接近4 点的样子，足足搞了快5 个小时。透过窄窄的窗子所看到的已经是很惨淡的阳光了。回过神来今天已经是公历新年后的第3 天了
    
    </summary>
    
      <category term="日常" scheme="https://arondight.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="开始" scheme="https://arondight.github.io/tags/%E5%BC%80%E5%A7%8B/"/>
    
  </entry>
  
</feed>
